 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _rubout:
 0000 0820              .byte 8,32
 0002 0800              .byte 8,0
 0004                   .dbfile C:\Users\addis\Desktop\ECE381\RS2322\RS2322\main.c
 0004                   .dbsym s rubout _rubout A[4:4]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\RS2322\RS2322\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\RS2322\RS2322\main.c
 0000                   .dbfunc e GetNumber _GetNumber fc
 0000           ;              c -> X+0
 0000           ;            max -> X-5
 0000           ;            min -> X-4
 0000           _GetNumber::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3801              add SP,1
 0004                   .dbline 16
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "string.h"
 0004           ; 
 0004           ; static char rubout[4] = { 0x08, 0x20, 0x08, 0x00 }; // Rubout Sequence consists of Backspace Space Backspace. This is the null-terminated string
 0004           ; 
 0004           ; char str[4][17]; // Multi-dimensional array of 4 strings with a length of 17
 0004           ; 
 0004           ; // This function reads characters from the serial until a character is entered that is within the min & max ASCII characters.
 0004           ; // That character is returned
 0004           ; char GetNumber(char min, char max)
 0004           ; {
 0004 8034              xjmp L3
 0006           L2:
 0006                   .dbline 20
 0006           ;       char c;
 0006           ;       
 0006           ;       while (1)
 0006           ;       {
 0006                   .dbline 21
 0006           ;               c = UART_cReadChar(); // Read the character
 0006 10                push X
 0007 7C0000            xcall _UART_cReadChar
 000A 20                pop X
 000B 62D000            mov REG[0xd0],>__r0
 000E 5400              mov [X+0],A
 0010                   .dbline 22
 0010           ;               if (c < ('0' + min) || c > ('0' + max)) // If the character is not within min to max range, continue the loop
 0010 52FC              mov A,[X-4]
 0012 0130              add A,48
 0014 5300              mov [__r0],A
 0016 5200              mov A,[X+0]
 0018 3A00              cmp A,[__r0]
 001A C00C              jc L7
 001C           X1:
 001C 62D000            mov REG[0xd0],>__r0
 001F 52FB              mov A,[X-5]
 0021 0130              add A,48
 0023 3B00              cmp A,[X+0]
 0025 D003              jnc L5
 0027           X2:
 0027           L7:
 0027                   .dbline 23
 0027           ;                       continue;
 0027 8011              xjmp L3
 0029           L5:
 0029                   .dbline 25
 0029           ;               
 0029           ;               UART_PutChar(c); // Put the character on the serial
 0029 10                push X
 002A 5200              mov A,[X+0]
 002C 7C0000            xcall _UART_PutChar
 002F 20                pop X
 0030                   .dbline 26
 0030           ;               return (c - '0'); // This returns the integer number entered instead of the ASCII value
 0030 62D000            mov REG[0xd0],>__r0
 0033 5200              mov A,[X+0]
 0035 1130              sub A,48
 0037 8003              xjmp L1
 0039           L3:
 0039                   .dbline 19
 0039 8FCC              xjmp L2
 003B           X0:
 003B                   .dbline -2
 003B           L1:
 003B 38FF              add SP,-1
 003D 20                pop X
 003E                   .dbline 0 ; func end
 003E 7F                ret
 003F                   .dbsym l c 0 c
 003F                   .dbsym l max -5 c
 003F                   .dbsym l min -4 c
 003F                   .dbend
 003F                   .dbfunc e GetLine _GetLine fV
 003F           ;         strPos -> X+1
 003F           ;              c -> X+0
 003F           ;      bufferLen -> X-6
 003F           ;         buffer -> X-5
 003F           _GetLine::
 003F                   .dbline -1
 003F 10                push X
 0040 4F                mov X,SP
 0041 3802              add SP,2
 0043                   .dbline 34
 0043           ;       }
 0043           ;       
 0043           ;       return 0;
 0043           ; }
 0043           ; 
 0043           ; // This function get's a line of text. It writes data into buffer with a maximum size of bufferLen. The function returns when enter is pressed
 0043           ; void GetLine(char *buffer, char bufferLen)
 0043           ; {
 0043                   .dbline 36
 0043           ;       char c;
 0043           ;       char strPos = 0; // Current position in the string
 0043 560100            mov [X+1],0
 0046 8095              xjmp L10
 0048           L9:
 0048                   .dbline 39
 0048           ;       
 0048           ;       while (1)
 0048           ;       {
 0048                   .dbline 40
 0048           ;               c = UART_cReadChar(); // Read the character
 0048 10                push X
 0049 7C0000            xcall _UART_cReadChar
 004C 20                pop X
 004D 62D000            mov REG[0xd0],>__r0
 0050 5400              mov [X+0],A
 0052                   .dbline 42
 0052           ;               
 0052           ;               if (c == 0x08 || c == 0x7F) // Delete or backspace pressed
 0052 3D0008            cmp [X+0],8
 0055 A006              jz L14
 0057 3D007F            cmp [X+0],127
 005A B017              jnz L12
 005C           L14:
 005C                   .dbline 44
 005C           ;               {
 005C           ;                       if (strPos > 0) // Only delete if there are characters to delete
 005C                   .dbline 44
 005C 5000              mov A,0
 005E 3B01              cmp A,[X+1]
 0060 D07B              jnc L13
 0062           X4:
 0062                   .dbline 46
 0062           ;                       {
 0062           ;                               strPos--; // Set the position back one
 0062                   .dbline 46
 0062 7B01              dec [X+1]
 0064                   .dbline 47
 0064           ;                               UART_PutString(rubout); // Sends the rubout sequence to the serial.
 0064 10                push X
 0065 5000              mov A,>_rubout
 0067 08                push A
 0068 5000              mov A,<_rubout
 006A 5C                mov X,A
 006B 18                pop A
 006C 7C0000            xcall _UART_PutString
 006F 20                pop X
 0070                   .dbline 48
 0070           ;                       }
 0070                   .dbline 49
 0070           ;               }
 0070 806B              xjmp L13
 0072           L12:
 0072                   .dbline 50
 0072           ;               else if (c == 0x0D) // Newline enter is pressed
 0072 3D000D            cmp [X+0],13
 0075 B028              jnz L17
 0077                   .dbline 52
 0077           ;               {
 0077           ;                       buffer[strPos+1] = 0x00; // Null-terminate the string
 0077                   .dbline 52
 0077 62D000            mov REG[0xd0],>__r0
 007A 5201              mov A,[X+1]
 007C 5300              mov [__r1],A
 007E 550000            mov [__r0],0
 0081 52FC              mov A,[X-4]
 0083 0400              add [__r1],A
 0085 52FB              mov A,[X-5]
 0087 0C00              adc [__r0],A
 0089 060001            add [__r1],1
 008C 0E0000            adc [__r0],0
 008F 5100              mov A,[__r0]
 0091 60D5              mov REG[0xd5],A
 0093 5000              mov A,0
 0095 3F00              mvi [__r1],A
 0097                   .dbline 53
 0097           ;                       UART_PutCRLF(); // Go to another line
 0097 10                push X
 0098 7C0000            xcall _UART_PutCRLF
 009B 20                pop X
 009C                   .dbline 54
 009C           ;                       break;
 009C 8041              xjmp L8
 009E           L17:
 009E                   .dbline 56
 009E           ;               }
 009E           ;               else if (c >= 0x20 && c < 0x7F) // Only echo valid characters to the string. These are any alphabet, numeric, or symbols
 009E 3D0020            cmp [X+0],32
 00A1 C03A              jc L19
 00A3           X5:
 00A3 3D007F            cmp [X+0],127
 00A6 D035              jnc L19
 00A8           X6:
 00A8                   .dbline 58
 00A8           ;               {
 00A8           ;                       if (strPos < bufferLen) // If there is space in the buffer
 00A8                   .dbline 58
 00A8 5201              mov A,[X+1]
 00AA 3BFA              cmp A,[X-6]
 00AC D028              jnc L21
 00AE           X7:
 00AE                   .dbline 60
 00AE           ;                       {
 00AE           ;                               buffer[strPos++] = c; // Set the current character in buffer to c and then increment strPos
 00AE                   .dbline 60
 00AE 62D000            mov REG[0xd0],>__r0
 00B1 5201              mov A,[X+1]
 00B3 5300              mov [__r1],A
 00B5 550000            mov [__r0],0
 00B8 0101              add A,1
 00BA 5401              mov [X+1],A
 00BC 52FC              mov A,[X-4]
 00BE 0400              add [__r1],A
 00C0 52FB              mov A,[X-5]
 00C2 0C00              adc [__r0],A
 00C4 5100              mov A,[__r0]
 00C6 60D5              mov REG[0xd5],A
 00C8 5200              mov A,[X+0]
 00CA 3F00              mvi [__r1],A
 00CC                   .dbline 61
 00CC           ;                               UART_PutChar(c); // Send the character to the computer
 00CC 10                push X
 00CD 5200              mov A,[X+0]
 00CF 7C0000            xcall _UART_PutChar
 00D2 20                pop X
 00D3                   .dbline 62
 00D3           ;                       }
 00D3 8008              xjmp L22
 00D5           L21:
 00D5                   .dbline 64
 00D5           ;                       else
 00D5           ;                               UART_PutChar(0x07); // Send BEL key because there is no more space left to add to the string
 00D5 10                push X
 00D6 5007              mov A,7
 00D8 7C0000            xcall _UART_PutChar
 00DB 20                pop X
 00DC           L22:
 00DC                   .dbline 65
 00DC           ;               }
 00DC           L19:
 00DC           L13:
 00DC                   .dbline 66
 00DC           ;       }
 00DC           L10:
 00DC                   .dbline 38
 00DC 8F6B              xjmp L9
 00DE           X3:
 00DE                   .dbline -2
 00DE           L8:
 00DE 38FE              add SP,-2
 00E0 20                pop X
 00E1                   .dbline 0 ; func end
 00E1 7F                ret
 00E2                   .dbsym l strPos 1 c
 00E2                   .dbsym l c 0 c
 00E2                   .dbsym l bufferLen -6 c
 00E2                   .dbsym l buffer -5 pc
 00E2                   .dbend
 00E2                   .dbfunc e main _main fV
 00E2           ;            opt -> X+0
 00E2           _main::
 00E2                   .dbline -1
 00E2 10                push X
 00E3 4F                mov X,SP
 00E4 3803              add SP,3
 00E6                   .dbline 71
 00E6           ;       return;
 00E6           ; }
 00E6           ; 
 00E6           ; void main(void)
 00E6           ; {
 00E6                   .dbline 74
 00E6           ;       char opt;
 00E6           ;       
 00E6           ;       LCD_Start();
 00E6 10                push X
 00E7 7C0000            xcall _LCD_Start
 00EA                   .dbline 75
 00EA           ;       UART_Start(UART_PARITY_NONE);
 00EA 5000              mov A,0
 00EC 7C0000            xcall _UART_Start
 00EF                   .dbline 76
 00EF           ;       Counter16_Start();
 00EF 7C0000            xcall _Counter16_Start
 00F2 20                pop X
 00F3                   .dbline 77
 00F3           ;       OSC_GO_EN |= 0x40;
 00F3 7110              or F,0x10  ; iopage = 1
 00F5 43DD40            or REG[0xdd],64
 00F8                   .dbline 79
 00F8           ;       
 00F8           ;       memset(str, 17 * 4, 0x00); // Initialize all four strings to 0x00
 00F8 5000              mov A,0
 00FA 08                push A
 00FB 08                push A
 00FC 08                push A
 00FD 5044              mov A,68
 00FF 08                push A
 0100 5000              mov A,>_str
 0102 08                push A
 0103 5000              mov A,<_str
 0105 08                push A
 0106 70CF              and F,0xCF      ; iopage = 0
 0108 7C0000            xcall _memsetLMM
 010B 38FA              add SP,-6
 010D 8166              xjmp L25
 010F           L24:
 010F                   .dbline 82
 010F           ;       
 010F           ;       while (1)
 010F           ;       {
 010F                   .dbline 84
 010F           ;               // \r\n is a CRLF \t is a tab. This prints out prompting user what to do
 010F           ;               UART_CPutString("What would you like to do?\r\n\t1. Write to string\r\n\t2. Print to screen\r\n\t3. Print to LCD\r\n");
 010F 10                push X
 0110 5062              mov A,>L27
 0112 08                push A
 0113 5062              mov A,<L27
 0115 5C                mov X,A
 0116 18                pop A
 0117 7C0000            xcall _UART_CPutString
 011A 20                pop X
 011B                   .dbline 85
 011B           ;               opt = GetNumber(1, 3); // Basically retrieves which option to do
 011B 5003              mov A,3
 011D 08                push A
 011E 5001              mov A,1
 0120 08                push A
 0121 9EDD              xcall _GetNumber
 0123 38FE              add SP,-2
 0125 62D000            mov REG[0xd0],>__r0
 0128 5400              mov [X+0],A
 012A                   .dbline 87
 012A           ;               
 012A           ;               UART_PutCRLF();
 012A 10                push X
 012B 7C0000            xcall _UART_PutCRLF
 012E 20                pop X
 012F                   .dbline 88
 012F           ;               switch (opt)
 012F 5200              mov A,[X+0]
 0131 5402              mov [X+2],A
 0133 560100            mov [X+1],0
 0136 3D0100            cmp [X+1],0
 0139 B006              jnz X9
 013B 3D0201            cmp [X+2],1
 013E A017              jz L31
 0140           X9:
 0140 3D0100            cmp [X+1],0
 0143 B006              jnz X10
 0145 3D0202            cmp [X+2],2
 0148 A067              jz L33
 014A           X10:
 014A 3D0100            cmp [X+1],0
 014D B006              jnz X11
 014F 3D0203            cmp [X+2],3
 0152 A0B7              jz L35
 0154           X11:
 0154 811F              xjmp L28
 0156           L31:
 0156                   .dbline 91
 0156           ;               {
 0156           ;                       case 1: // Write to string option
 0156           ;                               UART_CPutString("Which string would you like to write to: "); 
 0156 10                push X
 0157 5038              mov A,>L32
 0159 08                push A
 015A 5038              mov A,<L32
 015C 5C                mov X,A
 015D 18                pop A
 015E 7C0000            xcall _UART_CPutString
 0161 20                pop X
 0162                   .dbline 92
 0162           ;                               opt = GetNumber(0, 3); // Ask which string to edit
 0162 5003              mov A,3
 0164 08                push A
 0165 5000              mov A,0
 0167 08                push A
 0168 9E96              xcall _GetNumber
 016A 38FE              add SP,-2
 016C 62D000            mov REG[0xd0],>__r0
 016F 5400              mov [X+0],A
 0171                   .dbline 93
 0171           ;                               UART_PutCRLF();
 0171 10                push X
 0172 7C0000            xcall _UART_PutCRLF
 0175 20                pop X
 0176                   .dbline 95
 0176           ;                               
 0176           ;                               GetLine(str[opt], 16); // Allow the user to change the string
 0176 5010              mov A,16
 0178 08                push A
 0179 62D000            mov REG[0xd0],>__r0
 017C 5200              mov A,[X+0]
 017E 5300              mov [__r1],A
 0180 5000              mov A,0
 0182 08                push A
 0183 5100              mov A,[__r1]
 0185 08                push A
 0186 5000              mov A,0
 0188 08                push A
 0189 5011              mov A,17
 018B 08                push A
 018C 7C0000            xcall __mul16
 018F 38FC              add SP,-4
 0191 5100              mov A,[__rX]
 0193 5300              mov [__r1],A
 0195 5100              mov A,[__rY]
 0197 5300              mov [__r0],A
 0199 060000            add [__r1],<_str
 019C 0E0000            adc [__r0],>_str
 019F 5100              mov A,[__r0]
 01A1 08                push A
 01A2 5100              mov A,[__r1]
 01A4 08                push A
 01A5 9E98              xcall _GetLine
 01A7 38FD              add SP,-3
 01A9                   .dbline 96
 01A9           ;                               UART_PutCRLF();
 01A9 10                push X
 01AA 7C0000            xcall _UART_PutCRLF
 01AD 20                pop X
 01AE                   .dbline 97
 01AE           ;                               break;
 01AE 80C5              xjmp L29
 01B0           L33:
 01B0                   .dbline 100
 01B0           ;                       
 01B0           ;                       case 2: // Print to screen option
 01B0           ;                               UART_CPutString("Which string would you like to print: ");
 01B0 10                push X
 01B1 5011              mov A,>L34
 01B3 08                push A
 01B4 5011              mov A,<L34
 01B6 5C                mov X,A
 01B7 18                pop A
 01B8 7C0000            xcall _UART_CPutString
 01BB 20                pop X
 01BC                   .dbline 101
 01BC           ;                               opt = GetNumber(0, 3); // Ask which string to print
 01BC 5003              mov A,3
 01BE 08                push A
 01BF 5000              mov A,0
 01C1 08                push A
 01C2 9E3C              xcall _GetNumber
 01C4 38FE              add SP,-2
 01C6 62D000            mov REG[0xd0],>__r0
 01C9 5400              mov [X+0],A
 01CB                   .dbline 102
 01CB           ;                               UART_PutCRLF();
 01CB 10                push X
 01CC 7C0000            xcall _UART_PutCRLF
 01CF 20                pop X
 01D0                   .dbline 103
 01D0           ;                               UART_PutString(str[opt]); // Print selected string to UART
 01D0 62D000            mov REG[0xd0],>__r0
 01D3 5200              mov A,[X+0]
 01D5 5300              mov [__r1],A
 01D7 5000              mov A,0
 01D9 08                push A
 01DA 5100              mov A,[__r1]
 01DC 08                push A
 01DD 5000              mov A,0
 01DF 08                push A
 01E0 5011              mov A,17
 01E2 08                push A
 01E3 7C0000            xcall __mul16
 01E6 38FC              add SP,-4
 01E8 5100              mov A,[__rX]
 01EA 5300              mov [__r1],A
 01EC 5100              mov A,[__rY]
 01EE 5300              mov [__r0],A
 01F0 060000            add [__r1],<_str
 01F3 0E0000            adc [__r0],>_str
 01F6 10                push X
 01F7 5100              mov A,[__r0]
 01F9 08                push A
 01FA 5100              mov A,[__r1]
 01FC 5C                mov X,A
 01FD 18                pop A
 01FE 7C0000            xcall _UART_PutString
 0201                   .dbline 104
 0201           ;                               UART_PutCRLF();
 0201 7C0000            xcall _UART_PutCRLF
 0204                   .dbline 105
 0204           ;                               UART_PutCRLF();
 0204 7C0000            xcall _UART_PutCRLF
 0207 20                pop X
 0208                   .dbline 106
 0208           ;                               break;
 0208 806B              xjmp L29
 020A           L35:
 020A                   .dbline 109
 020A           ;                       
 020A           ;                       case 3: // Print to LCD option
 020A           ;                               UART_CPutString("Which string would you like to print: "); 
 020A 10                push X
 020B 5011              mov A,>L34
 020D 08                push A
 020E 5011              mov A,<L34
 0210 5C                mov X,A
 0211 18                pop A
 0212 7C0000            xcall _UART_CPutString
 0215 20                pop X
 0216                   .dbline 110
 0216           ;                               opt = GetNumber(0, 3); // Ask which string to print
 0216 5003              mov A,3
 0218 08                push A
 0219 5000              mov A,0
 021B 08                push A
 021C 9DE2              xcall _GetNumber
 021E 38FE              add SP,-2
 0220 62D000            mov REG[0xd0],>__r0
 0223 5400              mov [X+0],A
 0225                   .dbline 111
 0225           ;                               UART_PutCRLF();
 0225 10                push X
 0226 7C0000            xcall _UART_PutCRLF
 0229                   .dbline 113
 0229           ;                               
 0229           ;                               LCD_Position(1, 0);
 0229 5700              mov X,0
 022B 5001              mov A,1
 022D 7C0000            xcall _LCD_Position
 0230                   .dbline 114
 0230           ;                               LCD_PrCString("                "); // Clear out old value in LCD
 0230 5000              mov A,>L36
 0232 08                push A
 0233 5000              mov A,<L36
 0235 5C                mov X,A
 0236 18                pop A
 0237 7C0000            xcall _LCD_PrCString
 023A                   .dbline 115
 023A           ;                               LCD_Position(1, 0);
 023A 5700              mov X,0
 023C 5001              mov A,1
 023E 7C0000            xcall _LCD_Position
 0241 20                pop X
 0242                   .dbline 116
 0242           ;                               LCD_PrString(str[opt]); // Print selected string to LCD
 0242 62D000            mov REG[0xd0],>__r0
 0245 5200              mov A,[X+0]
 0247 5300              mov [__r1],A
 0249 5000              mov A,0
 024B 08                push A
 024C 5100              mov A,[__r1]
 024E 08                push A
 024F 5000              mov A,0
 0251 08                push A
 0252 5011              mov A,17
 0254 08                push A
 0255 7C0000            xcall __mul16
 0258 38FC              add SP,-4
 025A 5100              mov A,[__rX]
 025C 5300              mov [__r1],A
 025E 5100              mov A,[__rY]
 0260 5300              mov [__r0],A
 0262 060000            add [__r1],<_str
 0265 0E0000            adc [__r0],>_str
 0268 10                push X
 0269 5100              mov A,[__r0]
 026B 08                push A
 026C 5100              mov A,[__r1]
 026E 5C                mov X,A
 026F 18                pop A
 0270 7C0000            xcall _LCD_PrString
 0273 20                pop X
 0274                   .dbline 117
 0274           ;                               break;
 0274           L28:
 0274           L29:
 0274                   .dbline 119
 0274           ;               }
 0274           ;       }
 0274           L25:
 0274                   .dbline 81
 0274 8E9A              xjmp L24
 0276           X8:
 0276                   .dbline -2
 0276           L23:
 0276 38FD              add SP,-3
 0278 20                pop X
 0279                   .dbline 0 ; func end
 0279 8FFF              jmp .
 027B                   .dbsym l opt 0 c
 027B                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\RS2322\RS2322\main.c
 0000           _str::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 0000000000000000  .byte 0,0,0,0,0,0,0,0
 0044                   .dbsym e str _str A[68:4:17]c
                        .area lit(rom, con, rel, lit)
 0000           L36:
 0000 20202020202020202020202020202020  .byte 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32
 0010 00                .byte 0
 0011           L34:
 0011 576869636820737472696E6720776F75  .byte 'W,'h,'i,'c,'h,32,'s,'t,'r,'i,'n,'g,32,'w,'o,'u
 0021 6C6420796F75206C696B6520746F2070  .byte 'l,'d,32,'y,'o,'u,32,'l,'i,'k,'e,32,'t,'o,32,'p
 0031 72696E743A2000    .byte 'r,'i,'n,'t,58,32,0
 0038           L32:
 0038 576869636820737472696E6720776F75  .byte 'W,'h,'i,'c,'h,32,'s,'t,'r,'i,'n,'g,32,'w,'o,'u
 0048 6C6420796F75206C696B6520746F2077  .byte 'l,'d,32,'y,'o,'u,32,'l,'i,'k,'e,32,'t,'o,32,'w
 0058 7269746520746F3A2000      .byte 'r,'i,'t,'e,32,'t,'o,58,32,0
 0062           L27:
 0062 5768617420776F756C6420796F75206C  .byte 'W,'h,'a,'t,32,'w,'o,'u,'l,'d,32,'y,'o,'u,32,'l
 0072 696B6520746F20646F3F0D0A09312E20  .byte 'i,'k,'e,32,'t,'o,32,'d,'o,63,13,10,9,49,46,32
 0082 577269746520746F20737472696E670D  .byte 'W,'r,'i,'t,'e,32,'t,'o,32,'s,'t,'r,'i,'n,'g,13
 0092 0A09322E205072696E7420746F207363  .byte 10,9,50,46,32,'P,'r,'i,'n,'t,32,'t,'o,32,'s,'c
 00A2 7265656E0D0A09332E205072696E7420  .byte 'r,'e,'e,'n,13,10,9,51,46,32,'P,'r,'i,'n,'t,32
 00B2 746F204C43440D0A00        .byte 't,'o,32,'L,'C,'D,13,10,0
