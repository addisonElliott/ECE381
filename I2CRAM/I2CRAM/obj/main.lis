 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _rubout:
 0000 0820              .byte 8,32
 0002 0800              .byte 8,0
 0004                   .dbfile C:\Users\Jacob\Desktop\ECE381\I2CRAM\I2CRAM\main.c
 0004                   .dbsym s rubout _rubout A[4:4]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Jacob\Desktop\ECE381\I2CRAM\I2CRAM\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\Jacob\Desktop\ECE381\I2CRAM\I2CRAM\main.c
 0000                   .dbfunc e GetNumber _GetNumber fc
 0000           ;              c -> X+0
 0000           ;            max -> X-5
 0000           ;            min -> X-4
 0000           _GetNumber::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3801              add SP,1
 0004                   .dbline 19
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "string.h"           // used for any of the string fcns supported by API
 0004           ; #include "stdio.h"            // this is used for fcns....
 0004           ; #include "ctype.h"            // this is used for fcns.. csspanf() and cstork()
 0004           ; 
 0004           ; static char rubout[4] = { 0x08, 0x20, 0x08, 0x00 }; // Rubout Sequence consists of Backspace Space Backspace. This is the null-terminated string
 0004           ; 
 0004           ; char buf[80]; // global array for user cmd and entry
 0004           ; char data[256];       // all the spots in memory
 0004           ; 
 0004           ; // This function reads characters from the serial until a character is entered that is within the min & max ASCII characters.
 0004           ; // That character is returned
 0004           ; char GetNumber(char min, char max)    // gets passed
 0004           ; {
 0004 8034              xjmp L3
 0006           L2:
 0006                   .dbline 23
 0006           ;       char c;
 0006           ;       
 0006           ;       while (1)
 0006           ;       {
 0006                   .dbline 24
 0006           ;               c = UART_cReadChar(); // Read the character
 0006 10                push X
 0007 7C0000            xcall _UART_cReadChar
 000A 20                pop X
 000B 62D000            mov REG[0xd0],>__r0
 000E 5400              mov [X+0],A
 0010                   .dbline 25
 0010           ;               if (c < ('0' + min) || c > ('0' + max)) // If the character is not within min to max range, continue the loop
 0010 52FC              mov A,[X-4]
 0012 0130              add A,48
 0014 5300              mov [__r0],A
 0016 5200              mov A,[X+0]
 0018 3A00              cmp A,[__r0]
 001A C00C              jc L7
 001C           X1:
 001C 62D000            mov REG[0xd0],>__r0
 001F 52FB              mov A,[X-5]
 0021 0130              add A,48
 0023 3B00              cmp A,[X+0]
 0025 D003              jnc L5
 0027           X2:
 0027           L7:
 0027                   .dbline 26
 0027           ;                       continue;
 0027 8011              xjmp L3
 0029           L5:
 0029                   .dbline 28
 0029           ;               
 0029           ;               UART_PutChar(c); // Put the character on the serial
 0029 10                push X
 002A 5200              mov A,[X+0]
 002C 7C0000            xcall _UART_PutChar
 002F 20                pop X
 0030                   .dbline 29
 0030           ;               return (c - '0'); // This returns the integer number entered instead of the ASCII value
 0030 62D000            mov REG[0xd0],>__r0
 0033 5200              mov A,[X+0]
 0035 1130              sub A,48
 0037 8003              xjmp L1
 0039           L3:
 0039                   .dbline 22
 0039 8FCC              xjmp L2
 003B           X0:
 003B                   .dbline -2
 003B           L1:
 003B 38FF              add SP,-1
 003D 20                pop X
 003E                   .dbline 0 ; func end
 003E 7F                ret
 003F                   .dbsym l c 0 c
 003F                   .dbsym l max -5 c
 003F                   .dbsym l min -4 c
 003F                   .dbend
 003F                   .dbfunc e GetLine _GetLine fc
 003F           ;         strPos -> X+1
 003F           ;              c -> X+0
 003F           ;      bufferLen -> X-6
 003F           ;         buffer -> X-5
 003F           _GetLine::
 003F                   .dbline -1
 003F 10                push X
 0040 4F                mov X,SP
 0041 3802              add SP,2
 0043                   .dbline 38
 0043           ;       }
 0043           ;       
 0043           ;       return 0;
 0043           ; }
 0043           ; 
 0043           ; // This function get's a line of text. It writes data into buffer with a maximum size of bufferLen. The function returns number of bytes written
 0043           ; // when enter is pressed
 0043           ; char GetLine(char *buffer, char bufferLen)
 0043           ; {
 0043                   .dbline 40
 0043           ;       char c;
 0043           ;       char strPos = 0; // Current position in the string
 0043 560100            mov [X+1],0
 0046                   .dbline 42
 0046           ;       
 0046           ;       UART_PutChar('>'); // print line pointer
 0046 10                push X
 0047 503E              mov A,62
 0049 7C0000            xcall _UART_PutChar
 004C 20                pop X
 004D 8094              xjmp L10
 004F           L9:
 004F                   .dbline 45
 004F           ;       
 004F           ;       while (1)
 004F           ;       {
 004F                   .dbline 46
 004F           ;               c = UART_cReadChar(); // Use UART module to read the character user enters
 004F 10                push X
 0050 7C0000            xcall _UART_cReadChar
 0053 20                pop X
 0054 62D000            mov REG[0xd0],>__r0
 0057 5400              mov [X+0],A
 0059                   .dbline 48
 0059           ;               
 0059           ;               if (c == 0x08 || c == 0x7F) // Delete or backspace pressed
 0059 3D0008            cmp [X+0],8
 005C A006              jz L14
 005E 3D007F            cmp [X+0],127
 0061 B017              jnz L12
 0063           L14:
 0063                   .dbline 50
 0063           ;               {
 0063           ;                       if (strPos > 0) // Only delete if there are characters to delete
 0063                   .dbline 50
 0063 5000              mov A,0
 0065 3B01              cmp A,[X+1]
 0067 D07A              jnc L13
 0069           X4:
 0069                   .dbline 52
 0069           ;                       {
 0069           ;                               strPos--; // Set the position back one
 0069                   .dbline 52
 0069 7B01              dec [X+1]
 006B                   .dbline 53
 006B           ;                               UART_PutString(rubout); // Sends the rubout sequence to the serial.
 006B 10                push X
 006C 5000              mov A,>_rubout
 006E 08                push A
 006F 5000              mov A,<_rubout
 0071 5C                mov X,A
 0072 18                pop A
 0073 7C0000            xcall _UART_PutString
 0076 20                pop X
 0077                   .dbline 54
 0077           ;                       }
 0077                   .dbline 55
 0077           ;               }
 0077 806A              xjmp L13
 0079           L12:
 0079                   .dbline 56
 0079           ;               else if (c == 0x0D) // Newline enter is pressed
 0079 3D000D            cmp [X+0],13
 007C B027              jnz L17
 007E                   .dbline 58
 007E           ;               {
 007E           ;                       buffer[strPos] = 0x00; // put the null character at the current strPos
 007E                   .dbline 58
 007E 62D000            mov REG[0xd0],>__r0
 0081 5201              mov A,[X+1]
 0083 5300              mov [__r1],A
 0085 550000            mov [__r0],0
 0088 52FC              mov A,[X-4]
 008A 0400              add [__r1],A
 008C 52FB              mov A,[X-5]
 008E 0C00              adc [__r0],A
 0090 5100              mov A,[__r0]
 0092 60D5              mov REG[0xd5],A
 0094 5000              mov A,0
 0096 3F00              mvi [__r1],A
 0098                   .dbline 59
 0098           ;                       UART_PutCRLF(); // Go to another line
 0098 10                push X
 0099 7C0000            xcall _UART_PutCRLF
 009C 20                pop X
 009D                   .dbline 60
 009D           ;                       return strPos;
 009D 5201              mov A,[X+1]
 009F 62D000            mov REG[0xd0],>__r0
 00A2 8041              xjmp L8
 00A4           L17:
 00A4                   .dbline 62
 00A4           ;               }
 00A4           ;               else if (c >= 0x20 && c < 0x7F) // only valid characters to the string. These are any alphabet, numeric, or symbols
 00A4 3D0020            cmp [X+0],32
 00A7 C03A              jc L19
 00A9           X5:
 00A9 3D007F            cmp [X+0],127
 00AC D035              jnc L19
 00AE           X6:
 00AE                   .dbline 64
 00AE           ;               {
 00AE           ;                       if (strPos < bufferLen) // If there is space in the buffer
 00AE                   .dbline 64
 00AE 5201              mov A,[X+1]
 00B0 3BFA              cmp A,[X-6]
 00B2 D028              jnc L21
 00B4           X7:
 00B4                   .dbline 66
 00B4           ;                       {
 00B4           ;                               buffer[strPos++] = c; // Set the current character in buffer to c and then increment strPos
 00B4                   .dbline 66
 00B4 62D000            mov REG[0xd0],>__r0
 00B7 5201              mov A,[X+1]
 00B9 5300              mov [__r1],A
 00BB 550000            mov [__r0],0
 00BE 0101              add A,1
 00C0 5401              mov [X+1],A
 00C2 52FC              mov A,[X-4]
 00C4 0400              add [__r1],A
 00C6 52FB              mov A,[X-5]
 00C8 0C00              adc [__r0],A
 00CA 5100              mov A,[__r0]
 00CC 60D5              mov REG[0xd5],A
 00CE 5200              mov A,[X+0]
 00D0 3F00              mvi [__r1],A
 00D2                   .dbline 67
 00D2           ;                               UART_PutChar(c); // Send the character to the computer
 00D2 10                push X
 00D3 5200              mov A,[X+0]
 00D5 7C0000            xcall _UART_PutChar
 00D8 20                pop X
 00D9                   .dbline 68
 00D9           ;                       }
 00D9 8008              xjmp L22
 00DB           L21:
 00DB                   .dbline 70
 00DB           ;                       else
 00DB           ;                               UART_PutChar(0x07); // Send BEL key because there is no more space left to add to the string
 00DB 10                push X
 00DC 5007              mov A,7
 00DE 7C0000            xcall _UART_PutChar
 00E1 20                pop X
 00E2           L22:
 00E2                   .dbline 71
 00E2           ;               }
 00E2           L19:
 00E2           L13:
 00E2                   .dbline 72
 00E2           ;       }
 00E2           L10:
 00E2                   .dbline 44
 00E2 8F6C              xjmp L9
 00E4           X3:
 00E4                   .dbline -2
 00E4           L8:
 00E4 38FE              add SP,-2
 00E6 20                pop X
 00E7                   .dbline 0 ; func end
 00E7 7F                ret
 00E8                   .dbsym l strPos 1 c
 00E8                   .dbsym l c 0 c
 00E8                   .dbsym l bufferLen -6 c
 00E8                   .dbsym l buffer -5 pc
 00E8                   .dbend
 00E8                   .dbfunc e HexConversion _HexConversion fI
 00E8           ;              i -> X+6
 00E8           ;           temp -> X+4
 00E8           ;            str -> X+2
 00E8           ;             ii -> X+0
 00E8           ;            dst -> X-7
 00E8           ;            src -> X-5
 00E8           _HexConversion::
 00E8                   .dbline -1
 00E8 10                push X
 00E9 4F                mov X,SP
 00EA 3808              add SP,8
 00EC                   .dbline 80
 00EC           ;       
 00EC           ;       return 0;
 00EC           ; }
 00EC           ; 
 00EC           ; // This takes a string that has hex such as 'A4 FF 01 04' and converts it into a string containing the hex files. Returns -1 if error, otherwise it returns
 00EC           ; // the number of bytes converted
 00EC           ; int HexConversion(char *src, char *dst)
 00EC           ; {
 00EC                   .dbline 82
 00EC           ;       char *str; // pointer to char array local to fcn        
 00EC           ;     int i = 0;        // return int
 00EC 560700            mov [X+7],0
 00EF 560600            mov [X+6],0
 00F2                   .dbline 83
 00F2           ;     int ii = 0; // for loop indexing
 00F2 560100            mov [X+1],0
 00F5 560000            mov [X+0],0
 00F8                   .dbline 86
 00F8           ;       int temp;       // 
 00F8           ; 
 00F8           ;     str = cstrtok(src, " ");
 00F8 5064              mov A,>L24
 00FA 08                push A
 00FB 5064              mov A,<L24
 00FD 08                push A
 00FE 52FB              mov A,[X-5]
 0100 08                push A
 0101 52FC              mov A,[X-4]
 0103 08                push A
 0104 7C0000            xcall _cstrtok
 0107 38FC              add SP,-4
 0109 62D000            mov REG[0xd0],>__r0
 010C 5100              mov A,[__r1]
 010E 5403              mov [X+3],A
 0110 5100              mov A,[__r0]
 0112 5402              mov [X+2],A
 0114           L25:
 0114                   .dbline 88
 0114           ;     do
 0114           ;     {
 0114                   .dbline 89
 0114           ;         if (strlen(str) != 2)
 0114 5202              mov A,[X+2]
 0116 08                push A
 0117 5203              mov A,[X+3]
 0119 08                push A
 011A 7C0000            xcall _strlenLMM
 011D 38FE              add SP,-2
 011F 62D000            mov REG[0xd0],>__r0
 0122 3C0000            cmp [__r0],0
 0125 B006              jnz X8
 0127 3C0002            cmp [__r1],2
 012A A00C              jz L28
 012C           X8:
 012C                   .dbline 90
 012C           ;             return -1;
 012C 62D000            mov REG[0xd0],>__r0
 012F 5500FF            mov [__r1],-1
 0132 5500FF            mov [__r0],-1
 0135 80D3              xjmp L23
 0137           L28:
 0137                   .dbline 92
 0137           ; 
 0137           ;         for (ii = 0; ii < strlen(str); ++ii)
 0137 560100            mov [X+1],0
 013A 560000            mov [X+0],0
 013D 803C              xjmp L33
 013F           L30:
 013F                   .dbline 93
 013F           ;             if (!isxdigit(str[ii]))
 013F 62D000            mov REG[0xd0],>__r0
 0142 5201              mov A,[X+1]
 0144 0303              add A,[X+3]
 0146 5300              mov [__r1],A
 0148 5200              mov A,[X+0]
 014A 0B02              adc A,[X+2]
 014C 60D4              mov REG[0xd4],A
 014E 3E00              mvi A,[__r1]
 0150 5300              mov [__r1],A
 0152 5000              mov A,0
 0154 08                push A
 0155 5100              mov A,[__r1]
 0157 08                push A
 0158 7C0000            xcall _isxdigit
 015B 38FE              add SP,-2
 015D 62D000            mov REG[0xd0],>__r0
 0160 3C0000            cmp [__r0],0
 0163 B011              jnz L34
 0165 3C0000            cmp [__r1],0
 0168 B00C              jnz L34
 016A           X9:
 016A                   .dbline 94
 016A           ;                 return -1;
 016A 62D000            mov REG[0xd0],>__r0
 016D 5500FF            mov [__r1],-1
 0170 5500FF            mov [__r0],-1
 0173 8095              xjmp L23
 0175           L34:
 0175           L31:
 0175                   .dbline 92
 0175 7701              inc [X+1]
 0177 0F0000            adc [X+0],0
 017A           L33:
 017A                   .dbline 92
 017A 5202              mov A,[X+2]
 017C 08                push A
 017D 5203              mov A,[X+3]
 017F 08                push A
 0180 7C0000            xcall _strlenLMM
 0183 38FE              add SP,-2
 0185 62D000            mov REG[0xd0],>__r0
 0188 5201              mov A,[X+1]
 018A 1200              sub A,[__r1]
 018C 5200              mov A,[X+0]
 018E 1A00              sbb A,[__r0]
 0190 CFAE              jc L30
 0192           X10:
 0192                   .dbline 96
 0192           ; 
 0192           ;         csscanf(str, "%x", &temp);
 0192 62D000            mov REG[0xd0],>__r0
 0195 5A00              mov [__r1],X
 0197 060004            add [__r1],4
 019A 5007              mov A,7
 019C 08                push A
 019D 5100              mov A,[__r1]
 019F 08                push A
 01A0 5061              mov A,>L36
 01A2 08                push A
 01A3 5061              mov A,<L36
 01A5 08                push A
 01A6 5202              mov A,[X+2]
 01A8 08                push A
 01A9 5203              mov A,[X+3]
 01AB 08                push A
 01AC 7C0000            xcall _csscanf
 01AF                   .dbline 97
 01AF           ;               dst[i++] = temp;
 01AF 62D000            mov REG[0xd0],>__r0
 01B2 5207              mov A,[X+7]
 01B4 5300              mov [__r1],A
 01B6 5206              mov A,[X+6]
 01B8 5300              mov [__r0],A
 01BA 5100              mov A,[__r1]
 01BC 0101              add A,1
 01BE 5407              mov [X+7],A
 01C0 5100              mov A,[__r0]
 01C2 0900              adc A,0
 01C4 5406              mov [X+6],A
 01C6 5205              mov A,[X+5]
 01C8 5300              mov [__r2],A
 01CA 52FA              mov A,[X-6]
 01CC 0400              add [__r1],A
 01CE 52F9              mov A,[X-7]
 01D0 0C00              adc [__r0],A
 01D2 5100              mov A,[__r0]
 01D4 60D5              mov REG[0xd5],A
 01D6 5100              mov A,[__r2]
 01D8 3F00              mvi [__r1],A
 01DA                   .dbline 98
 01DA           ;         str = cstrtok(0x00, " ");
 01DA 5064              mov A,>L24
 01DC 08                push A
 01DD 5064              mov A,<L24
 01DF 08                push A
 01E0 5000              mov A,0
 01E2 08                push A
 01E3 08                push A
 01E4 7C0000            xcall _cstrtok
 01E7 38F6              add SP,-10
 01E9 62D000            mov REG[0xd0],>__r0
 01EC 5100              mov A,[__r1]
 01EE 5403              mov [X+3],A
 01F0 5100              mov A,[__r0]
 01F2 5402              mov [X+2],A
 01F4                   .dbline 99
 01F4           ;     } while (str != 0x00);
 01F4           L26:
 01F4                   .dbline 99
 01F4 3D0200            cmp [X+2],0
 01F7 BF1C              jnz L25
 01F9 3D0300            cmp [X+3],0
 01FC BF17              jnz L25
 01FE           X11:
 01FE                   .dbline 101
 01FE           ; 
 01FE           ;     return i;
 01FE 62D000            mov REG[0xd0],>__r0
 0201 5207              mov A,[X+7]
 0203 5300              mov [__r1],A
 0205 5206              mov A,[X+6]
 0207 5300              mov [__r0],A
 0209                   .dbline -2
 0209           L23:
 0209 38F8              add SP,-8
 020B 20                pop X
 020C                   .dbline 0 ; func end
 020C 7F                ret
 020D                   .dbsym l i 6 I
 020D                   .dbsym l temp 4 I
 020D                   .dbsym l str 2 pc
 020D                   .dbsym l ii 0 I
 020D                   .dbsym l dst -7 pc
 020D                   .dbsym l src -5 pc
 020D                   .dbend
 020D                   .dbfunc e Lowercase _Lowercase fpc
 020D           ;              i -> X+0
 020D           ;            str -> X-5
 020D           _Lowercase::
 020D                   .dbline -1
 020D 10                push X
 020E 4F                mov X,SP
 020F 3804              add SP,4
 0211                   .dbline 105
 0211           ; }
 0211           ; 
 0211           ; char *Lowercase(char *str)
 0211           ; {
 0211                   .dbline 107
 0211           ;       int i;
 0211           ;       for (i = 0; str[i] != '\0'; ++i)
 0211 560100            mov [X+1],0
 0214 560000            mov [X+0],0
 0217 8043              xjmp L41
 0219           L38:
 0219                   .dbline 108
 0219           ;               str[i] = tolower(str[i]);
 0219 62D000            mov REG[0xd0],>__r0
 021C 5201              mov A,[X+1]
 021E 03FC              add A,[X-4]
 0220 5300              mov [__r1],A
 0222 5200              mov A,[X+0]
 0224 0BFB              adc A,[X-5]
 0226 5300              mov [__r0],A
 0228 5100              mov A,[__r1]
 022A 5403              mov [X+3],A
 022C 5100              mov A,[__r0]
 022E 5402              mov [X+2],A
 0230 60D4              mov REG[0xd4],A
 0232 3E00              mvi A,[__r1]
 0234 7A00              dec [__r1]
 0236 5300              mov [__r3],A
 0238 5000              mov A,0
 023A 08                push A
 023B 5100              mov A,[__r3]
 023D 08                push A
 023E 7C0000            xcall _tolower
 0241 38FE              add SP,-2
 0243 62D000            mov REG[0xd0],>__r0
 0246 5100              mov A,[__r1]
 0248 5300              mov [__r0],A
 024A 5203              mov A,[X+3]
 024C 5300              mov [__r3],A
 024E 5202              mov A,[X+2]
 0250 60D5              mov REG[0xd5],A
 0252 5100              mov A,[__r0]
 0254 3F00              mvi [__r3],A
 0256           L39:
 0256                   .dbline 107
 0256 7701              inc [X+1]
 0258 0F0000            adc [X+0],0
 025B           L41:
 025B                   .dbline 107
 025B 62D000            mov REG[0xd0],>__r0
 025E 5201              mov A,[X+1]
 0260 03FC              add A,[X-4]
 0262 5300              mov [__r1],A
 0264 5200              mov A,[X+0]
 0266 0BFB              adc A,[X-5]
 0268 60D4              mov REG[0xd4],A
 026A 3E00              mvi A,[__r1]
 026C 3900              cmp A,0
 026E BFAA              jnz L38
 0270                   .dbline 110
 0270           ;       
 0270           ;       return str;
 0270 52FC              mov A,[X-4]
 0272 5300              mov [__r1],A
 0274 52FB              mov A,[X-5]
 0276 5300              mov [__r0],A
 0278                   .dbline -2
 0278           L37:
 0278 38FC              add SP,-4
 027A 20                pop X
 027B                   .dbline 0 ; func end
 027B 7F                ret
 027C                   .dbsym l i 0 I
 027C                   .dbsym l str -5 pc
 027C                   .dbend
 027C                   .dbfunc e main _main fV
 027C           ;         memLoc -> X+16
 027C           ;   groupAddress -> X+14
 027C           ;       dataType -> X+13
 027C           ;         hexStr -> X+9
 027C           ;       numBytes -> X+7
 027C           ;              i -> X+5
 027C           ;         memLoc -> X+10
 027C           ;            len -> X+8
 027C           ;   groupAddress -> X+6
 027C           ;       dataType -> X+5
 027C           ;   slaveAddress -> X+4
 027C           ;            cmd -> X+2
 027C           ;         params -> X+0
 027C           _main::
 027C                   .dbline -1
 027C 10                push X
 027D 4F                mov X,SP
 027E 3812              add SP,18
 0280                   .dbline 114
 0280           ; }
 0280           ; 
 0280           ; void main(void)
 0280           ; {     
 0280                   .dbline 115
 0280           ;       M8C_EnableGInt ; // Uncomment this line to enable Global Interrupts
 0280 7101                      or  F, 01h
 0282           
 0282                   .dbline 117
 0282           ;       // User Interface
 0282           ;       UART_Start(UART_PARITY_NONE);
 0282 10                push X
 0283 5000              mov A,0
 0285 7C0000            xcall _UART_Start
 0288                   .dbline 119
 0288           ;       // clock for moving serial
 0288           ;       Counter16_Start();
 0288 7C0000            xcall _Counter16_Start
 028B                   .dbline 121
 028B           ;       // used to debug
 028B           ;       LCD_Start();
 028B 7C0000            xcall _LCD_Start
 028E                   .dbline 123
 028E           ;       // initialize and enable the I2C module
 028E           ;       I2CHW_Start();
 028E 7C0000            xcall _I2CHW_Start
 0291                   .dbline 124
 0291           ;       I2CHW_EnableMstr();
 0291 7C0000            xcall _I2CHW_EnableMstr
 0294                   .dbline 125
 0294           ;       I2CHW_EnableInt();
 0294 7C0000            xcall _I2CHW_EnableInt
 0297                   .dbline 127
 0297           ; // user guide for cmd window
 0297           ;       UART_CPutString("########################## I2C External SRAM ########################\r\n\
 0297 50B8              mov A,>L43
 0299 08                push A
 029A 50B8              mov A,<L43
 029C 5C                mov X,A
 029D 18                pop A
 029E 7C0000            xcall _UART_CPutString
 02A1 20                pop X
 02A2 85FA              xjmp L45
 02A4           L44:
 02A4                   .dbline 145
 02A4           ; #     W # XX T [Data]\r\n\
 02A4           ; #             W    - Write command\r\n\
 02A4           ; #             #    - Group Address (0 - 7)\r\n\
 02A4           ; #             XX   - Memory Location in hex (00 - FF)\r\n\
 02A4           ; #             T    - Data Type, either A for ASCII or H for Hexadecimal\r\n\
 02A4           ; #             Data - Either ASCII string or Hexadecimal separates by spaces\r\n\
 02A4           ; #\t\t\tA - Mary had a little lamb\r\n\
 02A4           ; #\t\t\tH - 01 FF A0 0F D8 C3\r\n\
 02A4           ; #\r\n\
 02A4           ; #     R # XX T NN\r\n\
 02A4           ; #             R    - Read command\r\n\
 02A4           ; #             #    - Group Address (0 - 7)\r\n\
 02A4           ; #             XX   - Memory Location in hex (00 - FF)\r\n\
 02A4           ; #             T    - Data Type, either A for ASCII or H for Hexadecimal\r\n\
 02A4           ; #             NN       - Number of bytes to read in hexadecimal\r\n\
 02A4           ; #####################################################################\r\n");
 02A4           ;       while (1)
 02A4           ;       {
 02A4                   .dbline 148
 02A4           ;               char *cmd;
 02A4           ;               char *params;   // most widely buffer
 02A4           ;               char slaveAddress = 0x50;               // 01010000'0' R/W shifted to front
 02A4 560450            mov [X+4],80
 02A7                   .dbline 150
 02A7           ;               
 02A7           ;               GetLine(buf, 79); // passing ref to global char array and max length of cmd entry
 02A7 504F              mov A,79
 02A9 08                push A
 02AA 5000              mov A,>_buf
 02AC 08                push A
 02AD 5000              mov A,<_buf
 02AF 08                push A
 02B0 9D8D              xcall _GetLine
 02B2 38FD              add SP,-3
 02B4 62D000            mov REG[0xd0],>__r0
 02B7                   .dbline 152
 02B7           ;                                                       // return value not used
 02B7           ;               memset(data, 0x00, 256);        // initialize all the set {data} to zero
 02B7 5001              mov A,1
 02B9 08                push A
 02BA 5000              mov A,0
 02BC 08                push A
 02BD 08                push A
 02BE 08                push A
 02BF 5000              mov A,>_data
 02C1 08                push A
 02C2 5000              mov A,<_data
 02C4 08                push A
 02C5 7C0000            xcall _memsetLMM
 02C8                   .dbline 153
 02C8           ;               cmd = Lowercase(cstrtok(buf, " "));     
 02C8 5064              mov A,>L24
 02CA 08                push A
 02CB 5064              mov A,<L24
 02CD 08                push A
 02CE 5000              mov A,>_buf
 02D0 08                push A
 02D1 5000              mov A,<_buf
 02D3 08                push A
 02D4 7C0000            xcall _cstrtok
 02D7 38F6              add SP,-10
 02D9 62D000            mov REG[0xd0],>__r0
 02DC 5100              mov A,[__r0]
 02DE 08                push A
 02DF 5100              mov A,[__r1]
 02E1 08                push A
 02E2 9F29              xcall _Lowercase
 02E4 62D000            mov REG[0xd0],>__r0
 02E7 5100              mov A,[__r1]
 02E9 5403              mov [X+3],A
 02EB 5100              mov A,[__r0]
 02ED 5402              mov [X+2],A
 02EF                   .dbline 154
 02EF           ;               if (strlen(cmd) == 1 && cmd[0] == 'w')
 02EF 5202              mov A,[X+2]
 02F1 08                push A
 02F2 5203              mov A,[X+3]
 02F4 08                push A
 02F5 7C0000            xcall _strlenLMM
 02F8 38FC              add SP,-4
 02FA 62D000            mov REG[0xd0],>__r0
 02FD 3C0000            cmp [__r0],0
 0300 B275              jnz L47
 0302 3C0001            cmp [__r1],1
 0305 B270              jnz L47
 0307           X13:
 0307 62D000            mov REG[0xd0],>__r0
 030A 5203              mov A,[X+3]
 030C 5300              mov [__r1],A
 030E 5202              mov A,[X+2]
 0310 60D4              mov REG[0xd4],A
 0312 3E00              mvi A,[__r1]
 0314 3977              cmp A,119
 0316 B25F              jnz L47
 0318                   .dbline 156
 0318           ;               {       
 0318           ;                       int groupAddress; // only 1 and 2 actually go to SRAM
 0318                   .dbline 162
 0318           ;                       int memLoc;
 0318           ;                       char dataType;
 0318           ;                       
 0318           ;                       int len;
 0318           ;                       
 0318           ;                       params = cstrtok(0x00, " ");  // this statement begins in buf where previous delimiter left off
 0318 5064              mov A,>L24
 031A 08                push A
 031B 5064              mov A,<L24
 031D 08                push A
 031E 5000              mov A,0
 0320 08                push A
 0321 08                push A
 0322 7C0000            xcall _cstrtok
 0325 62D000            mov REG[0xd0],>__r0
 0328 5100              mov A,[__r1]
 032A 5401              mov [X+1],A
 032C 5100              mov A,[__r0]
 032E 5400              mov [X+0],A
 0330                   .dbline 168
 0330           ;                                                                                       // after getting the cmd from buf. it goes to next space delimiter
 0330           ;                       
 0330           ;                       // csscanf() used to assign initialize groupAdress, memLoc, and dataType.  also makes for easy length validation
 0330           ;                       // condtion to test the 0 or 1 int representation of the group address
 0330           ;                               // csscanf(const * char, %interrpret read type as, store in location) returns an integer
 0330           ;                       if (strlen(params) != 1 || csscanf(params, "%d", &groupAddress) != 1) goto error;
 0330 5200              mov A,[X+0]
 0332 08                push A
 0333 5201              mov A,[X+1]
 0335 08                push A
 0336 7C0000            xcall _strlenLMM
 0339 38FA              add SP,-6
 033B 62D000            mov REG[0xd0],>__r0
 033E 3C0000            cmp [__r0],0
 0341 B032              jnz L52
 0343 3C0001            cmp [__r1],1
 0346 B02D              jnz L52
 0348           X14:
 0348 62D000            mov REG[0xd0],>__r0
 034B 5A00              mov [__r1],X
 034D 060006            add [__r1],6
 0350 5007              mov A,7
 0352 08                push A
 0353 5100              mov A,[__r1]
 0355 08                push A
 0356 50B5              mov A,>L51
 0358 08                push A
 0359 50B5              mov A,<L51
 035B 08                push A
 035C 5200              mov A,[X+0]
 035E 08                push A
 035F 5201              mov A,[X+1]
 0361 08                push A
 0362 7C0000            xcall _csscanf
 0365 38FA              add SP,-6
 0367 62D000            mov REG[0xd0],>__r0
 036A 3C0000            cmp [__r0],0
 036D B006              jnz X15
 036F 3C0001            cmp [__r1],1
 0372 A003              jz L49
 0374           X15:
 0374           L52:
 0374                   .dbline 168
 0374 851C              xjmp L53
 0376           L49:
 0376                   .dbline 170
 0376           ;                       
 0376           ;                       params = cstrtok(0x00, " "); // get memLoc could be 00 to FF ( Mem(0) to Mem(255))
 0376 5064              mov A,>L24
 0378 08                push A
 0379 5064              mov A,<L24
 037B 08                push A
 037C 5000              mov A,0
 037E 08                push A
 037F 08                push A
 0380 7C0000            xcall _cstrtok
 0383 62D000            mov REG[0xd0],>__r0
 0386 5100              mov A,[__r1]
 0388 5401              mov [X+1],A
 038A 5100              mov A,[__r0]
 038C 5400              mov [X+0],A
 038E                   .dbline 171
 038E           ;                       if (strlen(params) != 2 || csscanf(params, "%x", &memLoc) != 1) goto error;
 038E 5200              mov A,[X+0]
 0390 08                push A
 0391 5201              mov A,[X+1]
 0393 08                push A
 0394 7C0000            xcall _strlenLMM
 0397 38FA              add SP,-6
 0399 62D000            mov REG[0xd0],>__r0
 039C 3C0000            cmp [__r0],0
 039F B032              jnz L56
 03A1 3C0002            cmp [__r1],2
 03A4 B02D              jnz L56
 03A6           X16:
 03A6 62D000            mov REG[0xd0],>__r0
 03A9 5A00              mov [__r1],X
 03AB 06000A            add [__r1],10
 03AE 5007              mov A,7
 03B0 08                push A
 03B1 5100              mov A,[__r1]
 03B3 08                push A
 03B4 5061              mov A,>L36
 03B6 08                push A
 03B7 5061              mov A,<L36
 03B9 08                push A
 03BA 5200              mov A,[X+0]
 03BC 08                push A
 03BD 5201              mov A,[X+1]
 03BF 08                push A
 03C0 7C0000            xcall _csscanf
 03C3 38FA              add SP,-6
 03C5 62D000            mov REG[0xd0],>__r0
 03C8 3C0000            cmp [__r0],0
 03CB B006              jnz X17
 03CD 3C0001            cmp [__r1],1
 03D0 A003              jz L54
 03D2           X17:
 03D2           L56:
 03D2                   .dbline 171
 03D2 84BE              xjmp L53
 03D4           L54:
 03D4                   .dbline 173
 03D4           ;                       
 03D4           ;                       params = cstrtok(0x00, " ");
 03D4 5064              mov A,>L24
 03D6 08                push A
 03D7 5064              mov A,<L24
 03D9 08                push A
 03DA 5000              mov A,0
 03DC 08                push A
 03DD 08                push A
 03DE 7C0000            xcall _cstrtok
 03E1 62D000            mov REG[0xd0],>__r0
 03E4 5100              mov A,[__r1]
 03E6 5401              mov [X+1],A
 03E8 5100              mov A,[__r0]
 03EA 5400              mov [X+0],A
 03EC                   .dbline 174
 03EC           ;                       if (strlen(params) != 1 || csscanf(params, "%c", &dataType) != 1) goto error;
 03EC 5200              mov A,[X+0]
 03EE 08                push A
 03EF 5201              mov A,[X+1]
 03F1 08                push A
 03F2 7C0000            xcall _strlenLMM
 03F5 38FA              add SP,-6
 03F7 62D000            mov REG[0xd0],>__r0
 03FA 3C0000            cmp [__r0],0
 03FD B032              jnz L60
 03FF 3C0001            cmp [__r1],1
 0402 B02D              jnz L60
 0404           X18:
 0404 62D000            mov REG[0xd0],>__r0
 0407 5A00              mov [__r1],X
 0409 060005            add [__r1],5
 040C 5007              mov A,7
 040E 08                push A
 040F 5100              mov A,[__r1]
 0411 08                push A
 0412 50B2              mov A,>L59
 0414 08                push A
 0415 50B2              mov A,<L59
 0417 08                push A
 0418 5200              mov A,[X+0]
 041A 08                push A
 041B 5201              mov A,[X+1]
 041D 08                push A
 041E 7C0000            xcall _csscanf
 0421 38FA              add SP,-6
 0423 62D000            mov REG[0xd0],>__r0
 0426 3C0000            cmp [__r0],0
 0429 B006              jnz X19
 042B 3C0001            cmp [__r1],1
 042E A003              jz L57
 0430           X19:
 0430           L60:
 0430                   .dbline 174
 0430 8460              xjmp L53
 0432           L57:
 0432                   .dbline 176
 0432           ;                       // after ascii or hex selection read the rest until null ( note new delimiter)
 0432           ;                       params = cstrtok(0x00, "\0");
 0432 50B0              mov A,>L61
 0434 08                push A
 0435 50B0              mov A,<L61
 0437 08                push A
 0438 5000              mov A,0
 043A 08                push A
 043B 08                push A
 043C 7C0000            xcall _cstrtok
 043F 62D000            mov REG[0xd0],>__r0
 0442 5100              mov A,[__r1]
 0444 5401              mov [X+1],A
 0446 5100              mov A,[__r0]
 0448 5400              mov [X+0],A
 044A                   .dbline 177
 044A           ;                       if (strlen(params) == 0 || params == 0x00) goto error;  // the set up command but didn't put anything in to write
 044A 5200              mov A,[X+0]
 044C 08                push A
 044D 5201              mov A,[X+1]
 044F 08                push A
 0450 7C0000            xcall _strlenLMM
 0453 38FA              add SP,-6
 0455 62D000            mov REG[0xd0],>__r0
 0458 3C0000            cmp [__r0],0
 045B B006              jnz X20
 045D 3C0000            cmp [__r1],0
 0460 A00B              jz L64
 0462           X20:
 0462 3D0000            cmp [X+0],0
 0465 B008              jnz L62
 0467 3D0100            cmp [X+1],0
 046A B003              jnz L62
 046C           X21:
 046C           L64:
 046C                   .dbline 177
 046C 8424              xjmp L53
 046E           L62:
 046E                   .dbline 179
 046E           ;                       
 046E           ;                       dataType = tolower(dataType); // Lowercase this stuff b/c case insensitive
 046E 62D000            mov REG[0xd0],>__r0
 0471 5205              mov A,[X+5]
 0473 5300              mov [__r1],A
 0475 5000              mov A,0
 0477 08                push A
 0478 5100              mov A,[__r1]
 047A 08                push A
 047B 7C0000            xcall _tolower
 047E 38FE              add SP,-2
 0480 62D000            mov REG[0xd0],>__r0
 0483 5100              mov A,[__r1]
 0485 5405              mov [X+5],A
 0487                   .dbline 180
 0487           ;                       if (groupAddress < 0 || groupAddress > 7)
 0487 5207              mov A,[X+7]
 0489 1100              sub A,0
 048B 5206              mov A,[X+6]
 048D 3180              xor A,-128
 048F 1980              sbb A,(0 ^ 0x80)
 0491 C014              jc L67
 0493           X22:
 0493 5007              mov A,7
 0495 1307              sub A,[X+7]
 0497 5206              mov A,[X+6]
 0499 3180              xor A,-128
 049B 62D000            mov REG[0xd0],>__r0
 049E 5300              mov [__rX],A
 04A0 5080              mov A,(0 ^ 0x80)
 04A2 1A00              sbb A,[__rX]
 04A4 D003              jnc L65
 04A6           X23:
 04A6           L67:
 04A6                   .dbline 181
 04A6           ;                               goto error;// groupAddress int representation is invalid
 04A6 83EA              xjmp L53
 04A8           L65:
 04A8                   .dbline 183
 04A8           ;                       
 04A8           ;                       data[0] = memLoc;       // begin to fill the global data[256] first byte is user hex mem entry
 04A8 520B              mov A,[X+11]
 04AA 62D000            mov REG[0xd0],>_data
 04AD 5300              mov [_data],A
 04AF                   .dbline 185
 04AF           ;                       
 04AF           ;                       slaveAddress |= groupAddress;   // adds group address to the slaveAddress
 04AF 62D000            mov REG[0xd0],>__r0
 04B2 5204              mov A,[X+4]
 04B4 5300              mov [__r1],A
 04B6 5207              mov A,[X+7]
 04B8 2C00              or [__r1],A
 04BA 5100              mov A,[__r1]
 04BC 5404              mov [X+4],A
 04BE                   .dbline 187
 04BE           ;                                                                                               // how does this work?? slaveAddress a char and groupAddress an int
 04BE           ;                       if (dataType == 'a') // check data type used to write or read
 04BE 3D0561            cmp [X+5],97
 04C1 B02E              jnz L68
 04C3                   .dbline 189
 04C3           ;                       {
 04C3           ;                               strcpy((data + 1), params); // If it wants ASCII, just copy it from params into data +1
 04C3                   .dbline 189
 04C3 5200              mov A,[X+0]
 04C5 08                push A
 04C6 5201              mov A,[X+1]
 04C8 08                push A
 04C9 5001              mov A,>_data+1
 04CB 08                push A
 04CC 5001              mov A,<_data+1
 04CE 08                push A
 04CF 7C0000            xcall _strcpyLMM
 04D2                   .dbline 191
 04D2           ;                                               // data + 1 (byte after memLoc) is destination, params is source copies dataType
 04D2           ;                               len = strlen((data + 1)) + 1; // length after pointing to data plus one measure then add 1 ??
 04D2 5001              mov A,>_data+1
 04D4 08                push A
 04D5 5001              mov A,<_data+1
 04D7 08                push A
 04D8 7C0000            xcall _strlenLMM
 04DB 38FA              add SP,-6
 04DD 62D000            mov REG[0xd0],>__r0
 04E0 060001            add [__r1],1
 04E3 0E0000            adc [__r0],0
 04E6 5100              mov A,[__r1]
 04E8 5409              mov [X+9],A
 04EA 5100              mov A,[__r0]
 04EC 5408              mov [X+8],A
 04EE                   .dbline 193
 04EE           ;                                                                                               // because memory location why is this twice????
 04EE           ;                       }
 04EE 8032              xjmp L69
 04F0           L68:
 04F0                   .dbline 194
 04F0           ;                       else if (dataType == 'h')
 04F0 3D0568            cmp [X+5],104
 04F3 B39D              jnz L53
 04F5                   .dbline 196
 04F5           ;                       {
 04F5           ;                               if ((len = HexConversion(params, (data + 1))) == -1) // Take hex data and convert to numbers into src + 1(src[0] has the memory loc)
 04F5                   .dbline 196
 04F5 5001              mov A,>_data+1
 04F7 08                push A
 04F8 5001              mov A,<_data+1
 04FA 08                push A
 04FB 5200              mov A,[X+0]
 04FD 08                push A
 04FE 5201              mov A,[X+1]
 0500 08                push A
 0501 9BE5              xcall _HexConversion
 0503 38FC              add SP,-4
 0505 62D000            mov REG[0xd0],>__r0
 0508 5100              mov A,[__r1]
 050A 5409              mov [X+9],A
 050C 5100              mov A,[__r0]
 050E 5408              mov [X+8],A
 0510 3C00FF            cmp [__r0],-1
 0513 B008              jnz L74
 0515 3C00FF            cmp [__r1],-1
 0518 B003              jnz L74
 051A           X24:
 051A                   .dbline 197
 051A           ;                                       goto error;
 051A 8376              xjmp L53
 051C           L74:
 051C                   .dbline 198
 051C           ;                               len++; // Add one to the length because of the memoryLocation
 051C 7709              inc [X+9]
 051E 0F0800            adc [X+8],0
 0521                   .dbline 199
 0521           ;                       }
 0521                   .dbline 201
 0521           ;                       else
 0521           ;                               goto error;
 0521           L73:
 0521           L69:
 0521                   .dbline 203
 0521           ;                       
 0521           ;                       I2CHW_bWriteBytes(slaveAddress, data, len, I2CHW_CompleteXfer); // Write it using Master Fcn 
 0521 10                push X
 0522 5000              mov A,0
 0524 08                push A
 0525 62D000            mov REG[0xd0],>__r0
 0528 5209              mov A,[X+9]
 052A 08                push A
 052B 5000              mov A,>_data
 052D 08                push A
 052E 5000              mov A,<_data
 0530 08                push A
 0531 5204              mov A,[X+4]
 0533 08                push A
 0534 7C0000            xcall _I2CHW_bWriteBytes
 0537 38FB              add SP,-5
 0539 20                pop X
 053A           L77:
 053A                   .dbline 204
 053A           ;                       while (!(I2CHW_bReadI2CStatus() & I2CHW_WR_COMPLETE));
 053A           L78:
 053A                   .dbline 204
 053A 10                push X
 053B 7C0000            xcall _I2CHW_bReadI2CStatus
 053E 20                pop X
 053F 62D000            mov REG[0xd0],>__r0
 0542 5300              mov [__r0],A
 0544 470040            tst [__r0],64
 0547 AFF2              jz L77
 0549                   .dbline 205
 0549           ;                       I2CHW_ClrWrStatus();
 0549 10                push X
 054A 7C0000            xcall _I2CHW_ClrWrStatus
 054D 20                pop X
 054E                   .dbline 207
 054E           ;                       
 054E           ;                       csprintf(data, "%x bytes were written", len); // Look up sprintf on Google for information 
 054E 5208              mov A,[X+8]
 0550 08                push A
 0551 5209              mov A,[X+9]
 0553 08                push A
 0554 509A              mov A,>L80
 0556 08                push A
 0557 509A              mov A,<L80
 0559 08                push A
 055A 5000              mov A,>_data
 055C 08                push A
 055D 5000              mov A,<_data
 055F 08                push A
 0560 7C0000            xcall _csprintf
 0563 38FA              add SP,-6
 0565                   .dbline 208
 0565           ;                       UART_PutString(data);
 0565 10                push X
 0566 5000              mov A,>_data
 0568 08                push A
 0569 5000              mov A,<_data
 056B 5C                mov X,A
 056C 18                pop A
 056D 7C0000            xcall _UART_PutString
 0570                   .dbline 209
 0570           ;                       UART_PutCRLF();
 0570 7C0000            xcall _UART_PutCRLF
 0573 20                pop X
 0574                   .dbline 210
 0574           ;               }
 0574 8328              xjmp L45
 0576           L47:
 0576                   .dbline 211
 0576           ;               else if (strlen(cmd) == 1 && cmd[0] == 'r')
 0576 5202              mov A,[X+2]
 0578 08                push A
 0579 5203              mov A,[X+3]
 057B 08                push A
 057C 7C0000            xcall _strlenLMM
 057F 38FE              add SP,-2
 0581 62D000            mov REG[0xd0],>__r0
 0584 3C0000            cmp [__r0],0
 0587 B309              jnz L53
 0589 3C0001            cmp [__r1],1
 058C B304              jnz L53
 058E           X25:
 058E 62D000            mov REG[0xd0],>__r0
 0591 5203              mov A,[X+3]
 0593 5300              mov [__r1],A
 0595 5202              mov A,[X+2]
 0597 60D4              mov REG[0xd4],A
 0599 3E00              mvi A,[__r1]
 059B 3972              cmp A,114
 059D B2F3              jnz L53
 059F                   .dbline 213
 059F           ;               {
 059F           ;                       int groupAddress;
 059F                   .dbline 221
 059F           ;                       int memLoc;
 059F           ;                       char dataType;
 059F           ;                       int numBytes;
 059F           ;                       
 059F           ;                       char hexStr[4];
 059F           ;                       int i;
 059F           ; 
 059F           ;                       params = cstrtok(0x00, " ");
 059F 5064              mov A,>L24
 05A1 08                push A
 05A2 5064              mov A,<L24
 05A4 08                push A
 05A5 5000              mov A,0
 05A7 08                push A
 05A8 08                push A
 05A9 7C0000            xcall _cstrtok
 05AC 62D000            mov REG[0xd0],>__r0
 05AF 5100              mov A,[__r1]
 05B1 5401              mov [X+1],A
 05B3 5100              mov A,[__r0]
 05B5 5400              mov [X+0],A
 05B7                   .dbline 222
 05B7           ;                       if (strlen(params) != 1 || csscanf(params, "%d", &groupAddress) != 1) goto error;
 05B7 5200              mov A,[X+0]
 05B9 08                push A
 05BA 5201              mov A,[X+1]
 05BC 08                push A
 05BD 7C0000            xcall _strlenLMM
 05C0 38FA              add SP,-6
 05C2 62D000            mov REG[0xd0],>__r0
 05C5 3C0000            cmp [__r0],0
 05C8 B032              jnz L85
 05CA 3C0001            cmp [__r1],1
 05CD B02D              jnz L85
 05CF           X26:
 05CF 62D000            mov REG[0xd0],>__r0
 05D2 5A00              mov [__r1],X
 05D4 06000E            add [__r1],14
 05D7 5007              mov A,7
 05D9 08                push A
 05DA 5100              mov A,[__r1]
 05DC 08                push A
 05DD 50B5              mov A,>L51
 05DF 08                push A
 05E0 50B5              mov A,<L51
 05E2 08                push A
 05E3 5200              mov A,[X+0]
 05E5 08                push A
 05E6 5201              mov A,[X+1]
 05E8 08                push A
 05E9 7C0000            xcall _csscanf
 05EC 38FA              add SP,-6
 05EE 62D000            mov REG[0xd0],>__r0
 05F1 3C0000            cmp [__r0],0
 05F4 B006              jnz X27
 05F6 3C0001            cmp [__r1],1
 05F9 A003              jz L83
 05FB           X27:
 05FB           L85:
 05FB                   .dbline 222
 05FB 8295              xjmp L53
 05FD           L83:
 05FD                   .dbline 224
 05FD           ;       
 05FD           ;                       params = cstrtok(0x00, " ");
 05FD 5064              mov A,>L24
 05FF 08                push A
 0600 5064              mov A,<L24
 0602 08                push A
 0603 5000              mov A,0
 0605 08                push A
 0606 08                push A
 0607 7C0000            xcall _cstrtok
 060A 62D000            mov REG[0xd0],>__r0
 060D 5100              mov A,[__r1]
 060F 5401              mov [X+1],A
 0611 5100              mov A,[__r0]
 0613 5400              mov [X+0],A
 0615                   .dbline 225
 0615           ;                       if (strlen(params) != 2 || csscanf(params, "%x", &memLoc) != 1) goto error;
 0615 5200              mov A,[X+0]
 0617 08                push A
 0618 5201              mov A,[X+1]
 061A 08                push A
 061B 7C0000            xcall _strlenLMM
 061E 38FA              add SP,-6
 0620 62D000            mov REG[0xd0],>__r0
 0623 3C0000            cmp [__r0],0
 0626 B032              jnz L88
 0628 3C0002            cmp [__r1],2
 062B B02D              jnz L88
 062D           X28:
 062D 62D000            mov REG[0xd0],>__r0
 0630 5A00              mov [__r1],X
 0632 060010            add [__r1],16
 0635 5007              mov A,7
 0637 08                push A
 0638 5100              mov A,[__r1]
 063A 08                push A
 063B 5061              mov A,>L36
 063D 08                push A
 063E 5061              mov A,<L36
 0640 08                push A
 0641 5200              mov A,[X+0]
 0643 08                push A
 0644 5201              mov A,[X+1]
 0646 08                push A
 0647 7C0000            xcall _csscanf
 064A 38FA              add SP,-6
 064C 62D000            mov REG[0xd0],>__r0
 064F 3C0000            cmp [__r0],0
 0652 B006              jnz X29
 0654 3C0001            cmp [__r1],1
 0657 A003              jz L86
 0659           X29:
 0659           L88:
 0659                   .dbline 225
 0659 8237              xjmp L53
 065B           L86:
 065B                   .dbline 227
 065B           ;                       
 065B           ;                       params = cstrtok(0x00, " ");
 065B 5064              mov A,>L24
 065D 08                push A
 065E 5064              mov A,<L24
 0660 08                push A
 0661 5000              mov A,0
 0663 08                push A
 0664 08                push A
 0665 7C0000            xcall _cstrtok
 0668 62D000            mov REG[0xd0],>__r0
 066B 5100              mov A,[__r1]
 066D 5401              mov [X+1],A
 066F 5100              mov A,[__r0]
 0671 5400              mov [X+0],A
 0673                   .dbline 228
 0673           ;                       if (strlen(params) != 1 || csscanf(params, "%c", &dataType) != 1) goto error;
 0673 5200              mov A,[X+0]
 0675 08                push A
 0676 5201              mov A,[X+1]
 0678 08                push A
 0679 7C0000            xcall _strlenLMM
 067C 38FA              add SP,-6
 067E 62D000            mov REG[0xd0],>__r0
 0681 3C0000            cmp [__r0],0
 0684 B032              jnz L91
 0686 3C0001            cmp [__r1],1
 0689 B02D              jnz L91
 068B           X30:
 068B 62D000            mov REG[0xd0],>__r0
 068E 5A00              mov [__r1],X
 0690 06000D            add [__r1],13
 0693 5007              mov A,7
 0695 08                push A
 0696 5100              mov A,[__r1]
 0698 08                push A
 0699 50B2              mov A,>L59
 069B 08                push A
 069C 50B2              mov A,<L59
 069E 08                push A
 069F 5200              mov A,[X+0]
 06A1 08                push A
 06A2 5201              mov A,[X+1]
 06A4 08                push A
 06A5 7C0000            xcall _csscanf
 06A8 38FA              add SP,-6
 06AA 62D000            mov REG[0xd0],>__r0
 06AD 3C0000            cmp [__r0],0
 06B0 B006              jnz X31
 06B2 3C0001            cmp [__r1],1
 06B5 A003              jz L89
 06B7           X31:
 06B7           L91:
 06B7                   .dbline 228
 06B7 81D9              xjmp L53
 06B9           L89:
 06B9                   .dbline 230
 06B9           ;                       
 06B9           ;                       params = cstrtok(0x00, " ");
 06B9 5064              mov A,>L24
 06BB 08                push A
 06BC 5064              mov A,<L24
 06BE 08                push A
 06BF 5000              mov A,0
 06C1 08                push A
 06C2 08                push A
 06C3 7C0000            xcall _cstrtok
 06C6 62D000            mov REG[0xd0],>__r0
 06C9 5100              mov A,[__r1]
 06CB 5401              mov [X+1],A
 06CD 5100              mov A,[__r0]
 06CF 5400              mov [X+0],A
 06D1                   .dbline 231
 06D1           ;                       if (strlen(params) != 2 || csscanf(params, "%x", &numBytes) != 1) goto error;
 06D1 5200              mov A,[X+0]
 06D3 08                push A
 06D4 5201              mov A,[X+1]
 06D6 08                push A
 06D7 7C0000            xcall _strlenLMM
 06DA 38FA              add SP,-6
 06DC 62D000            mov REG[0xd0],>__r0
 06DF 3C0000            cmp [__r0],0
 06E2 B032              jnz L94
 06E4 3C0002            cmp [__r1],2
 06E7 B02D              jnz L94
 06E9           X32:
 06E9 62D000            mov REG[0xd0],>__r0
 06EC 5A00              mov [__r1],X
 06EE 060007            add [__r1],7
 06F1 5007              mov A,7
 06F3 08                push A
 06F4 5100              mov A,[__r1]
 06F6 08                push A
 06F7 5061              mov A,>L36
 06F9 08                push A
 06FA 5061              mov A,<L36
 06FC 08                push A
 06FD 5200              mov A,[X+0]
 06FF 08                push A
 0700 5201              mov A,[X+1]
 0702 08                push A
 0703 7C0000            xcall _csscanf
 0706 38FA              add SP,-6
 0708 62D000            mov REG[0xd0],>__r0
 070B 3C0000            cmp [__r0],0
 070E B006              jnz X33
 0710 3C0001            cmp [__r1],1
 0713 A003              jz L92
 0715           X33:
 0715           L94:
 0715                   .dbline 231
 0715 817B              xjmp L53
 0717           L92:
 0717                   .dbline 233
 0717           ;                       
 0717           ;                       if (cstrtok(0x00, " ") != 0x00) goto error;
 0717 5064              mov A,>L24
 0719 08                push A
 071A 5064              mov A,<L24
 071C 08                push A
 071D 5000              mov A,0
 071F 08                push A
 0720 08                push A
 0721 7C0000            xcall _cstrtok
 0724 38FC              add SP,-4
 0726 62D000            mov REG[0xd0],>__r0
 0729 3C0000            cmp [__r0],0
 072C B006              jnz X34
 072E 3C0000            cmp [__r1],0
 0731 A003              jz L95
 0733           X34:
 0733                   .dbline 233
 0733 815D              xjmp L53
 0735           L95:
 0735                   .dbline 235
 0735           ;                       
 0735           ;                       dataType = tolower(dataType); // Lowercase this stuff b/c case insensitive
 0735 62D000            mov REG[0xd0],>__r0
 0738 520D              mov A,[X+13]
 073A 5300              mov [__r1],A
 073C 5000              mov A,0
 073E 08                push A
 073F 5100              mov A,[__r1]
 0741 08                push A
 0742 7C0000            xcall _tolower
 0745 38FE              add SP,-2
 0747 62D000            mov REG[0xd0],>__r0
 074A 5100              mov A,[__r1]
 074C 540D              mov [X+13],A
 074E                   .dbline 236
 074E           ;                       if (groupAddress < 0 || groupAddress > 7)
 074E 520F              mov A,[X+15]
 0750 1100              sub A,0
 0752 520E              mov A,[X+14]
 0754 3180              xor A,-128
 0756 1980              sbb A,(0 ^ 0x80)
 0758 C014              jc L99
 075A           X35:
 075A 5007              mov A,7
 075C 130F              sub A,[X+15]
 075E 520E              mov A,[X+14]
 0760 3180              xor A,-128
 0762 62D000            mov REG[0xd0],>__r0
 0765 5300              mov [__rX],A
 0767 5080              mov A,(0 ^ 0x80)
 0769 1A00              sbb A,[__rX]
 076B D003              jnc L97
 076D           X36:
 076D           L99:
 076D                   .dbline 237
 076D           ;                               goto error;
 076D 8123              xjmp L53
 076F           L97:
 076F                   .dbline 239
 076F           ;                       
 076F           ;                       data[0] = memLoc;
 076F 5211              mov A,[X+17]
 0771 62D000            mov REG[0xd0],>_data
 0774 5300              mov [_data],A
 0776                   .dbline 240
 0776           ;                       slaveAddress |= groupAddress;
 0776 62D000            mov REG[0xd0],>__r0
 0779 5204              mov A,[X+4]
 077B 5300              mov [__r1],A
 077D 520F              mov A,[X+15]
 077F 2C00              or [__r1],A
 0781 5100              mov A,[__r1]
 0783 5404              mov [X+4],A
 0785                   .dbline 242
 0785           ;                       
 0785           ;                       I2CHW_bWriteBytes(slaveAddress, data, 1, I2CHW_NoStop);
 0785 10                push X
 0786 5002              mov A,2
 0788 08                push A
 0789 5001              mov A,1
 078B 08                push A
 078C 5000              mov A,>_data
 078E 08                push A
 078F 5000              mov A,<_data
 0791 08                push A
 0792 5204              mov A,[X+4]
 0794 08                push A
 0795 7C0000            xcall _I2CHW_bWriteBytes
 0798 38FB              add SP,-5
 079A 20                pop X
 079B           L100:
 079B                   .dbline 243
 079B           ;                       while (!(I2CHW_bReadI2CStatus() & I2CHW_WR_COMPLETE));
 079B           L101:
 079B                   .dbline 243
 079B 10                push X
 079C 7C0000            xcall _I2CHW_bReadI2CStatus
 079F 20                pop X
 07A0 62D000            mov REG[0xd0],>__r0
 07A3 5300              mov [__r0],A
 07A5 470040            tst [__r0],64
 07A8 AFF2              jz L100
 07AA                   .dbline 244
 07AA           ;                       I2CHW_ClrWrStatus();
 07AA 10                push X
 07AB 7C0000            xcall _I2CHW_ClrWrStatus
 07AE 20                pop X
 07AF                   .dbline 246
 07AF           ;                       
 07AF           ;                       I2CHW_fReadBytes(slaveAddress, data, numBytes, I2CHW_CompleteXfer);
 07AF 10                push X
 07B0 5000              mov A,0
 07B2 08                push A
 07B3 62D000            mov REG[0xd0],>__r0
 07B6 5208              mov A,[X+8]
 07B8 08                push A
 07B9 5000              mov A,>_data
 07BB 08                push A
 07BC 5000              mov A,<_data
 07BE 08                push A
 07BF 5204              mov A,[X+4]
 07C1 08                push A
 07C2 7C0000            xcall _I2CHW_fReadBytes
 07C5 38FB              add SP,-5
 07C7 20                pop X
 07C8           L103:
 07C8                   .dbline 247
 07C8           ;                       while(!(I2CHW_bReadI2CStatus() & I2CHW_RD_COMPLETE));
 07C8           L104:
 07C8                   .dbline 247
 07C8 10                push X
 07C9 7C0000            xcall _I2CHW_bReadI2CStatus
 07CC 20                pop X
 07CD 62D000            mov REG[0xd0],>__r0
 07D0 5300              mov [__r0],A
 07D2 470004            tst [__r0],4
 07D5 AFF2              jz L103
 07D7                   .dbline 248
 07D7           ;                       I2CHW_ClrRdStatus();
 07D7 10                push X
 07D8 7C0000            xcall _I2CHW_ClrRdStatus
 07DB 20                pop X
 07DC                   .dbline 250
 07DC           ;                       
 07DC           ;                       if (dataType == 'a')
 07DC 3D0D61            cmp [X+13],97
 07DF B040              jnz L106
 07E1                   .dbline 252
 07E1           ;                       {
 07E1           ;                               for (i = 0; i < numBytes; ++i)
 07E1                   .dbline 252
 07E1 560600            mov [X+6],0
 07E4 560500            mov [X+5],0
 07E7 801C              xjmp L111
 07E9           L108:
 07E9                   .dbline 253
 07E9           ;                                       UART_PutChar(data[i]);
 07E9 62D000            mov REG[0xd0],>__r0
 07EC 5206              mov A,[X+6]
 07EE 0100              add A,<_data
 07F0 5300              mov [__r1],A
 07F2 5205              mov A,[X+5]
 07F4 0900              adc A,>_data
 07F6 60D4              mov REG[0xd4],A
 07F8 3E00              mvi A,[__r1]
 07FA 10                push X
 07FB 7C0000            xcall _UART_PutChar
 07FE 20                pop X
 07FF           L109:
 07FF                   .dbline 252
 07FF 7706              inc [X+6]
 0801 0F0500            adc [X+5],0
 0804           L111:
 0804                   .dbline 252
 0804 5206              mov A,[X+6]
 0806 1308              sub A,[X+8]
 0808 5207              mov A,[X+7]
 080A 3180              xor A,-128
 080C 62D000            mov REG[0xd0],>__r0
 080F 5300              mov [__rX],A
 0811 5205              mov A,[X+5]
 0813 3180              xor A,-128
 0815 1A00              sbb A,[__rX]
 0817 CFD1              jc L108
 0819           X37:
 0819                   .dbline 254
 0819           ;                               UART_PutCRLF();
 0819 10                push X
 081A 7C0000            xcall _UART_PutCRLF
 081D 20                pop X
 081E                   .dbline 255
 081E           ;                       }
 081E 807E              xjmp L45
 0820           L106:
 0820                   .dbline 256
 0820           ;                       else if (dataType == 'h')
 0820 3D0D68            cmp [X+13],104
 0823 B06D              jnz L53
 0825                   .dbline 258
 0825           ;                       {
 0825           ;                               for (i = 0; i < numBytes; ++i)
 0825                   .dbline 258
 0825 560600            mov [X+6],0
 0828 560500            mov [X+5],0
 082B 8049              xjmp L117
 082D           L114:
 082D                   .dbline 259
 082D           ;                               {
 082D                   .dbline 260
 082D           ;                                       csprintf(hexStr, "%X ", data[i]);
 082D 62D000            mov REG[0xd0],>__r0
 0830 5206              mov A,[X+6]
 0832 0100              add A,<_data
 0834 5300              mov [__r1],A
 0836 5205              mov A,[X+5]
 0838 0900              adc A,>_data
 083A 60D4              mov REG[0xd4],A
 083C 3E00              mvi A,[__r1]
 083E 5300              mov [__r1],A
 0840 5000              mov A,0
 0842 08                push A
 0843 5100              mov A,[__r1]
 0845 08                push A
 0846 5096              mov A,>L118
 0848 08                push A
 0849 5096              mov A,<L118
 084B 08                push A
 084C 5A00              mov [__r1],X
 084E 060009            add [__r1],9
 0851 5007              mov A,7
 0853 08                push A
 0854 5100              mov A,[__r1]
 0856 08                push A
 0857 7C0000            xcall _csprintf
 085A 38FA              add SP,-6
 085C                   .dbline 261
 085C           ;                                       UART_PutString(hexStr);
 085C 62D000            mov REG[0xd0],>__r0
 085F 5A00              mov [__r1],X
 0861 060009            add [__r1],9
 0864 10                push X
 0865 5007              mov A,7
 0867 08                push A
 0868 5100              mov A,[__r1]
 086A 5C                mov X,A
 086B 18                pop A
 086C 7C0000            xcall _UART_PutString
 086F 20                pop X
 0870                   .dbline 262
 0870           ;                               }
 0870           L115:
 0870                   .dbline 258
 0870 7706              inc [X+6]
 0872 0F0500            adc [X+5],0
 0875           L117:
 0875                   .dbline 258
 0875 5206              mov A,[X+6]
 0877 1308              sub A,[X+8]
 0879 5207              mov A,[X+7]
 087B 3180              xor A,-128
 087D 62D000            mov REG[0xd0],>__r0
 0880 5300              mov [__rX],A
 0882 5205              mov A,[X+5]
 0884 3180              xor A,-128
 0886 1A00              sbb A,[__rX]
 0888 CFA4              jc L114
 088A           X38:
 088A                   .dbline 263
 088A           ;                               UART_PutCRLF();
 088A 10                push X
 088B 7C0000            xcall _UART_PutCRLF
 088E 20                pop X
 088F                   .dbline 264
 088F           ;                       }
 088F                   .dbline 266
 088F           ;                       else
 088F           ;                               goto error;
 088F                   .dbline 267
 088F           ;               }
 088F                   .dbline 269
 088F           ;               else 
 088F           ;                       goto error;
 088F                   .dbline 271
 088F           ;               
 088F           ;               continue;
 088F 800D              xjmp L45
 0891           L53:
 0891                   .dbline 273
 0891           ;               error:
 0891           ;                       UART_CPutString("Invalid format entered. Valid formats are:\r\n\tW [GroupAddress] [MemoryLocation] [h|a] Hex/ASCII\r\n\tR [GroupAddress] [MemoryLocation] [h|a] [NumBytes]\r\n");
 0891 10                push X
 0892 5000              mov A,>L119
 0894 08                push A
 0895 5000              mov A,<L119
 0897 5C                mov X,A
 0898 18                pop A
 0899 7C0000            xcall _UART_CPutString
 089C 20                pop X
 089D                   .dbline 274
 089D           ;       }
 089D           L45:
 089D                   .dbline 144
 089D 8A06              xjmp L44
 089F           X12:
 089F                   .dbline -2
 089F           L42:
 089F 38EE              add SP,-18
 08A1 20                pop X
 08A2                   .dbline 0 ; func end
 08A2 8FFF              jmp .
 08A4                   .dbsym l memLoc 16 I
 08A4                   .dbsym l groupAddress 14 I
 08A4                   .dbsym l dataType 13 c
 08A4                   .dbsym l hexStr 9 A[4:4]c
 08A4                   .dbsym l numBytes 7 I
 08A4                   .dbsym l i 5 I
 08A4                   .dbsym l memLoc 10 I
 08A4                   .dbsym l len 8 I
 08A4                   .dbsym l groupAddress 6 I
 08A4                   .dbsym l dataType 5 c
 08A4                   .dbsym l slaveAddress 4 c
 08A4                   .dbsym l cmd 2 pc
 08A4                   .dbsym l params 0 pc
 08A4                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Jacob\Desktop\ECE381\I2CRAM\I2CRAM\main.c
 0000           _data::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 0078 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 00B4 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 00F0 00000000000000000000      .word 0,0,0,0,0
 00FA 000000000000      .byte 0,0,0,0,0,0
 0100                   .dbsym e data _data A[256:256]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Jacob\Desktop\ECE381\I2CRAM\I2CRAM\main.c
 0000           _buf::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 00000000000000000000      .word 0,0,0,0,0
 0046 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 0050                   .dbsym e buf _buf A[80:80]c
                        .area lit(rom, con, rel, lit)
 0000           L119:
 0000 496E76616C696420666F726D61742065  .byte 'I,'n,'v,'a,'l,'i,'d,32,'f,'o,'r,'m,'a,'t,32,'e
 0010 6E74657265642E2056616C696420666F  .byte 'n,'t,'e,'r,'e,'d,46,32,'V,'a,'l,'i,'d,32,'f,'o
 0020 726D617473206172653A0D0A0957205B  .byte 'r,'m,'a,'t,'s,32,'a,'r,'e,58,13,10,9,'W,32,91
 0030 47726F7570416464726573735D205B4D  .byte 'G,'r,'o,'u,'p,'A,'d,'d,'r,'e,'s,'s,93,32,91,'M
 0040 656D6F72794C6F636174696F6E5D205B  .byte 'e,'m,'o,'r,'y,'L,'o,'c,'a,'t,'i,'o,'n,93,32,91
 0050 687C615D204865782F41534349490D0A  .byte 'h,124,'a,93,32,'H,'e,'x,47,'A,'S,'C,'I,'I,13,10
 0060 0952205B47726F757041646472657373  .byte 9,'R,32,91,'G,'r,'o,'u,'p,'A,'d,'d,'r,'e,'s,'s
 0070 5D205B4D656D6F72794C6F636174696F  .byte 93,32,91,'M,'e,'m,'o,'r,'y,'L,'o,'c,'a,'t,'i,'o
 0080 6E5D205B687C615D205B4E756D427974  .byte 'n,93,32,91,'h,124,'a,93,32,91,'N,'u,'m,'B,'y,'t
 0090 65735D0D0A00      .byte 'e,'s,93,13,10,0
 0096           L118:
 0096 25582000          .byte 37,'X,32,0
 009A           L80:
 009A 25782062797465732077657265207772  .byte 37,'x,32,'b,'y,'t,'e,'s,32,'w,'e,'r,'e,32,'w,'r
 00AA 697474656E00      .byte 'i,'t,'t,'e,'n,0
 00B0           L61:
 00B0 0000              .byte 0,0
 00B2           L59:
 00B2 256300            .byte 37,'c,0
 00B5           L51:
 00B5 256400            .byte 37,'d,0
 00B8           L43:
 00B8 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 00C8 23232323232323232323204932432045  .byte 35,35,35,35,35,35,35,35,35,35,32,'I,50,'C,32,'E
 00D8 787465726E616C205352414D20232323  .byte 'x,'t,'e,'r,'n,'a,'l,32,'S,'R,'A,'M,32,35,35,35
 00E8 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 00F8 23232323230D0A230957202320585820  .byte 35,35,35,35,35,13,10,35,9,'W,32,35,32,'X,'X,32
 0108 54205B446174615D0D0A230909572020  .byte 'T,32,91,'D,'a,'t,'a,93,13,10,35,9,9,'W,32,32
 0118 20202D20577269746520636F6D6D616E  .byte 32,32,45,32,'W,'r,'i,'t,'e,32,'c,'o,'m,'m,'a,'n
 0128 640D0A23090923202020202D2047726F  .byte 'd,13,10,35,9,9,35,32,32,32,32,45,32,'G,'r,'o
 0138 75702041646472657373202830202D20  .byte 'u,'p,32,'A,'d,'d,'r,'e,'s,'s,32,40,48,32,45,32
 0148 37290D0A23090958582020202D204D65  .byte 55,41,13,10,35,9,9,'X,'X,32,32,32,45,32,'M,'e
 0158 6D6F7279204C6F636174696F6E20696E  .byte 'm,'o,'r,'y,32,'L,'o,'c,'a,'t,'i,'o,'n,32,'i,'n
 0168 2068657820283030202D204646290D0A  .byte 32,'h,'e,'x,32,40,48,48,32,45,32,'F,'F,41,13,10
 0178 23090954202020202D20446174612054  .byte 35,9,9,'T,32,32,32,32,45,32,'D,'a,'t,'a,32,'T
 0188 7970652C20656974686572204120666F  .byte 'y,'p,'e,44,32,'e,'i,'t,'h,'e,'r,32,'A,32,'f,'o
 0198 72204153434949206F72204820666F72  .byte 'r,32,'A,'S,'C,'I,'I,32,'o,'r,32,'H,32,'f,'o,'r
 01A8 2048657861646563696D616C0D0A2309  .byte 32,'H,'e,'x,'a,'d,'e,'c,'i,'m,'a,'l,13,10,35,9
 01B8 0944617461202D204569746865722041  .byte 9,'D,'a,'t,'a,32,45,32,'E,'i,'t,'h,'e,'r,32,'A
 01C8 5343494920737472696E67206F722048  .byte 'S,'C,'I,'I,32,'s,'t,'r,'i,'n,'g,32,'o,'r,32,'H
 01D8 657861646563696D616C207365706172  .byte 'e,'x,'a,'d,'e,'c,'i,'m,'a,'l,32,'s,'e,'p,'a,'r
 01E8 61746573206279207370616365730D0A  .byte 'a,'t,'e,'s,32,'b,'y,32,'s,'p,'a,'c,'e,'s,13,10
 01F8 2309090941202D204D61727920686164  .byte 35,9,9,9,'A,32,45,32,'M,'a,'r,'y,32,'h,'a,'d
 0208 2061206C6974746C65206C616D620D0A  .byte 32,'a,32,'l,'i,'t,'t,'l,'e,32,'l,'a,'m,'b,13,10
 0218 2309090948202D203031204646204130  .byte 35,9,9,9,'H,32,45,32,48,49,32,'F,'F,32,'A,48
 0228 2030462044382043330D0A230D0A2309  .byte 32,48,'F,32,'D,56,32,'C,51,13,10,35,13,10,35,9
 0238 5220232058582054204E4E0D0A230909  .byte 'R,32,35,32,'X,'X,32,'T,32,'N,'N,13,10,35,9,9
 0248 52202020202D205265616420636F6D6D  .byte 'R,32,32,32,32,45,32,'R,'e,'a,'d,32,'c,'o,'m,'m
 0258 616E640D0A23090923202020202D2047  .byte 'a,'n,'d,13,10,35,9,9,35,32,32,32,32,45,32,'G
 0268 726F7570204164647265737320283020  .byte 'r,'o,'u,'p,32,'A,'d,'d,'r,'e,'s,'s,32,40,48,32
 0278 2D2037290D0A23090958582020202D20  .byte 45,32,55,41,13,10,35,9,9,'X,'X,32,32,32,45,32
 0288 4D656D6F7279204C6F636174696F6E20  .byte 'M,'e,'m,'o,'r,'y,32,'L,'o,'c,'a,'t,'i,'o,'n,32
 0298 696E2068657820283030202D20464629  .byte 'i,'n,32,'h,'e,'x,32,40,48,48,32,45,32,'F,'F,41
 02A8 0D0A23090954202020202D2044617461  .byte 13,10,35,9,9,'T,32,32,32,32,45,32,'D,'a,'t,'a
 02B8 20547970652C20656974686572204120  .byte 32,'T,'y,'p,'e,44,32,'e,'i,'t,'h,'e,'r,32,'A,32
 02C8 666F72204153434949206F7220482066  .byte 'f,'o,'r,32,'A,'S,'C,'I,'I,32,'o,'r,32,'H,32,'f
 02D8 6F722048657861646563696D616C0D0A  .byte 'o,'r,32,'H,'e,'x,'a,'d,'e,'c,'i,'m,'a,'l,13,10
 02E8 2309094E4E09202D204E756D62657220  .byte 35,9,9,'N,'N,9,32,45,32,'N,'u,'m,'b,'e,'r,32
 02F8 6F6620627974657320746F2072656164  .byte 'o,'f,32,'b,'y,'t,'e,'s,32,'t,'o,32,'r,'e,'a,'d
 0308 20696E2068657861646563696D616C0D  .byte 32,'i,'n,32,'h,'e,'x,'a,'d,'e,'c,'i,'m,'a,'l,13
 0318 0A232323232323232323232323232323  .byte 10,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0328 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0338 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0348 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0358 2323232323230D0A00        .byte 35,35,35,35,35,35,13,10,0
 0361           L36:
 0361 257800            .byte 37,'x,0
 0364           L24:
 0364 2000              .byte 32,0
