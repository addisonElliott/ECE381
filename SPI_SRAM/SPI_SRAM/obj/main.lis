 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area lit(rom, con, rel, lit)
 0000           L2:
 0000 0001              .byte 0,1
 0002 4041              .byte 64,'A
 0004 8081              .byte 128,129
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\SPI_SRAM\SPI_SRAM\main.c
 0000                   .dbfunc e SPIRAM_StatusRegisterTest _SPIRAM_StatusRegisterTest fc
 0000           ;         status -> X+7
 0000           ;           mode -> X+1
 0000           ;              b -> X+0
 0000           _SPIRAM_StatusRegisterTest::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 111
 0004           ; //----------------------------------------------------------------------------
 0004           ; // 23K256 SPI SRAM Program
 0004           ; //
 0004           ; // PSoC Global Resources:
 0004           ; //   Power Setting     5.0V/24MHz
 0004           ; //   CPU_Clock         SysClk/1
 0004           ; //   32K_Select        Internal
 0004           ; //   PLL_Mode          Off
 0004           ; //   Sleep_Timer       8_Hz
 0004           ; //   VC1=SysClk/N     *12
 0004           ; //   VC2=VC1/N        *2
 0004           ; //                    * VC1 & VC2 values make VC2 = 1MHz = SPIM Clock
 0004           ; //   VC3_Source        SysClk/1
 0004           ; //   VC3 Divider      *52
 0004           ; //                    *Used to set UART baud rate to 57600
 0004           ; //   SysClk Source     Internal
 0004           ; //   SysClk*2 Disable  { Any }
 0004           ; //   Analog Power      { Any }
 0004           ; //   Ref Mux           { Any }
 0004           ; //   AGndBypass        { Any }
 0004           ; //   Op-Amp Bias       { Any }
 0004           ; //   A_Buff_Power      { Any }
 0004           ; //   SwitchModePump    OFF
 0004           ; //   Trip Voltage      { Any }
 0004           ; //   LVD ThrottleBack  Disable
 0004           ; //                    *When enabled, an LVD event forces the CPU Clock to SysClk/8.
 0004           ; //   Watchdog Enable  *{ Any }
 0004           ; //                    *Incautious use of the Watchdog may adversely affect timing
 0004           ; //
 0004           ; // SPIM Parameters
 0004           ; //   Name              SPIM
 0004           ; //   Clock            *VC2
 0004           ; //                    *1MHz = 500kbps SPI bit rate.
 0004           ; //   MISO              Row_2_Input_1
 0004           ; //   MOSI              Row_2_Output_0
 0004           ; //   SClk              Row_2_Output_3
 0004           ; //   Interrupt Mode    TXRegEmpty
 0004           ; //   ClockSync         Sync to SysClk
 0004           ; //   InvertMISO        Normal
 0004           ; //
 0004           ; // SPIM Module Notes
 0004           ; //   The 23K256 SPI SRAM has a maximum clock speed of 20MHz
 0004           ; //   SPIM Clock must be set to two times the desired bit rate
 0004           ; //   My prototype uses VC2 = SysClk/48 = 500kHz, yielding a bit rate of 250kbps
 0004           ; //   CS   = P12 (StdCPU:    Open Drain Low)
 0004           ; //   SCLK = P13 (GlobalOut: Open Drain Low)
 0004           ; //   MOSI = P14 (GlobalOut: Open Drain Low)
 0004           ; //   MISO = P15 (GlobalIn:  High Z)
 0004           ; //
 0004           ; // SPIM Modules Notes:
 0004           ; //  -Per Datasheet: The Row Input synchronization for MISO should be set to
 0004           ; //   Async for high SPI bit rates (>1Mbps).
 0004           ; //  -The SPIM Control Register contains the flags that are read by the
 0004           ; //   SPIM_bReadStatus() function. Reading clears all flags.
 0004           ; //  -The Datasheet for the SPIM Datasheet is inconsistent in its referral to
 0004           ; //   the SPIM_SPI_COMPLETE flag.  In the SPIM Control Register, it is named
 0004           ; //   SPI Done.
 0004           ; //  -The SPIM Module always transfers data present on the MISO pin when it
 0004           ; //   writes to the MOSI pin. In other words, it always transfers data into
 0004           ; //   the receive buffer while it is transferring data out of the transmit
 0004           ; //   buffer; it is essential to keep this in mind when checking flags.
 0004           ; //  -TX_BUFFER_EMPTY indicates that a new byte can be written to the TX Buffer.
 0004           ; //  -RX_BUFFER_FULL is set on the edge that captures the 8th bit of receive data.
 0004           ; //  -SPI_COMPLETE (an optional interrupt) is set when eight bits
 0004           ; //   of data and clock have been sent. In modes 0 and 1, this occurs one-half
 0004           ; //   cycle after RX_BUFFER_FULL is set; because in these modes, data is latched
 0004           ; //   on the leading edge of the clock and there is an additional one-half cycle
 0004           ; //   remaining to complete that clock. In modes 2 and 3, this occurs at the
 0004           ; //   same edge that the receive data is latched. This signal may be used to
 0004           ; //   read the received byte or it may be used by the SPIM to disable the
 0004           ; //   block after data transmission is complete.
 0004           ; //   See PSoC TRM, Document No. 001-14463 Rev. *G, Figure 17-19, page 358.
 0004           ; //  -Once the first byte to be transmitted is moved into the transmit buffer
 0004           ; //   by calling the SendTxData API, the SPIM module immediately moves the
 0004           ; //   byte into the transmit shift register one SPIM Clock Input cycle later
 0004           ; //   whereupon the TX_BUFFER_EMPTY flag is set immediately.
 0004           ; //   If another byte is written before the first byte has been fully shifted
 0004           ; //   out, it is placed in the transmit buffer and remains there until half-way
 0004           ; //   through the transmission of the 8th and final bit whereupon it is
 0004           ; //   automatically loaded into the transmit buffer which again sets the
 0004           ; //   TX_BUFFER_EMPTY flag and the 1st bit of the second byte begins
 0004           ; //   its transfer immediately after the 8th bit of the 1st byte. This allows
 0004           ; //   for uninterrupted back-to-back transmission.
 0004           ; //
 0004           ; // 23K256 Notes:
 0004           ; //  -Pins 4 & 8, the power pins, must have a 0.1uF decoupling capacitor
 0004           ; //   physically placed as close as possible to the IC package.
 0004           ; //  -Pin 7 (nHOLD) must be tied to Vcc since it is not used here.
 0004           ; //  -Pin 3 should be left floating since it is NC (no connection)
 0004           ; //  -3.3V SPI to 5V PSoC voltage translation is accomplished through 2.2k
 0004           ; //   pull-up resistors. This also limits the maximum reliable data transfer
 0004           ; //   rate due to the 2.2k*Cpin+wire time constant. Long wires are detrimental!
 0004           ; //
 0004           ; // bnoble@siue.edu 20140320
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "stdlib.h"
 0004           ; #include "spi_sram.h"
 0004           ; 
 0004           ; // Define our I/O array size. Powers of 2 are nice but not necessary
 0004           ; #define ARRAY_SIZE 64
 0004           ; 
 0004           ; // Globals
 0004           ; BYTE DataIn[ARRAY_SIZE];
 0004           ; BYTE DataOut[ARRAY_SIZE];
 0004           ; 
 0004           ; // Test reading and writing the 23K256 status register:
 0004           ; BYTE SPIRAM_StatusRegisterTest(void)
 0004           ; {
 0004                   .dbline 113
 0004           ;       // NOTE: SPIRAM_SEQUENTIAL_MODE|SPIRAM_PAGE_MODE is "Reserved", don't use it
 0004           ;       BYTE mode[6] = { SPIRAM_BYTE_MODE,
 0004 62D000            mov REG[0xd0],>__r0
 0007 550000            mov [__r1],<L2
 000A 550000            mov [__r0],>L2
 000D 5A00              mov [__r3],X
 000F 060001            add [__r3],1
 0012 62D507            mov REG[0xd5],7
 0015 10                push X
 0016 550000            mov [__rX],0
 0019 5100              mov A,[__r0]
 001B 5800              mov X,[__r1]
 001D           X0:
 001D 08                push A
 001E 28                romx
 001F 62D000            mov REG[0xd0],>__r0
 0022 3F00              mvi [__r3],A
 0024 18                pop A
 0025 75                inc X
 0026 0900              adc A,0
 0028 7600              inc [__rX]
 002A 3C0006            cmp [__rX],6
 002D BFEF              jnz X0
 002F                   .dbline 122
 002F           ;                                        SPIRAM_BYTE_MODE|SPIRAM_DISABLE_HOLD,
 002F           ;                                        SPIRAM_SEQUENTIAL_MODE,
 002F           ;                                        SPIRAM_SEQUENTIAL_MODE|SPIRAM_DISABLE_HOLD,
 002F           ;                                        SPIRAM_PAGE_MODE,
 002F           ;                                        SPIRAM_PAGE_MODE|SPIRAM_DISABLE_HOLD };
 002F           ;       BYTE status;
 002F           ;       BYTE b;
 002F           ; 
 002F           ;       UART_CPutString("Status Register W/R Test: 0x  ");
 002F 50BA              mov A,>L3
 0031 08                push A
 0032 50BA              mov A,<L3
 0034 5C                mov X,A
 0035 18                pop A
 0036 7C0000            xcall _UART_CPutString
 0039 20                pop X
 003A                   .dbline 123
 003A           ;       for (b=0; b<6 ; b++) {
 003A 560000            mov [X+0],0
 003D 809B              xjmp L7
 003F           L4:
 003F                   .dbline 123
 003F                   .dbline 124
 003F           ;               UART_PutChar(0x08);
 003F 10                push X
 0040 5008              mov A,8
 0042 7C0000            xcall _UART_PutChar
 0045                   .dbline 125
 0045           ;               UART_PutChar(0x08);
 0045 5008              mov A,8
 0047 7C0000            xcall _UART_PutChar
 004A 20                pop X
 004B                   .dbline 126
 004B           ;               UART_PutSHexByte(mode[b]);
 004B 62D000            mov REG[0xd0],>__r0
 004E 550007            mov [__r0],7
 0051 5A00              mov [__r1],X
 0053 060001            add [__r1],1
 0056 5200              mov A,[X+0]
 0058 0200              add A,[__r1]
 005A 5300              mov [__r1],A
 005C 5000              mov A,0
 005E 0A00              adc A,[__r0]
 0060 60D4              mov REG[0xd4],A
 0062 3E00              mvi A,[__r1]
 0064 10                push X
 0065 7C0000            xcall _UART_PutSHexByte
 0068 20                pop X
 0069                   .dbline 127
 0069           ;               if (SPIRAM_WriteStatusRegister(mode[b])) {
 0069 62D000            mov REG[0xd0],>__r0
 006C 550007            mov [__r0],7
 006F 5A00              mov [__r1],X
 0071 060001            add [__r1],1
 0074 5200              mov A,[X+0]
 0076 0200              add A,[__r1]
 0078 5300              mov [__r1],A
 007A 5000              mov A,0
 007C 0A00              adc A,[__r0]
 007E 60D4              mov REG[0xd4],A
 0080 3E00              mvi A,[__r1]
 0082 08                push A
 0083 7C0000            xcall _SPIRAM_WriteStatusRegister
 0086 38FF              add SP,-1
 0088 62D000            mov REG[0xd0],>__r0
 008B 3900              cmp A,0
 008D A010              jz L8
 008F                   .dbline 128
 008F           ;                       UART_CPutString("\r\nWrite of invalid Status Register value. System halted.\r\n");
 008F                   .dbline 128
 008F 10                push X
 0090 507F              mov A,>L10
 0092 08                push A
 0093 507F              mov A,<L10
 0095 5C                mov X,A
 0096 18                pop A
 0097 7C0000            xcall _UART_CPutString
 009A 20                pop X
 009B                   .dbline 129
 009B           ;                       M8C_Stop;
 009B 43FF01            or REG[0xff],1
 009E                   .dbline 130
 009E           ;               }
 009E           L8:
 009E                   .dbline 131
 009E           ;               status = SPIRAM_ReadStatusRegister();
 009E 7C0000            xcall _SPIRAM_ReadStatusRegister
 00A1 62D000            mov REG[0xd0],>__r0
 00A4 5407              mov [X+7],A
 00A6                   .dbline 132
 00A6           ;               if (status != mode[b]) {
 00A6 550007            mov [__r0],7
 00A9 5A00              mov [__r1],X
 00AB 060001            add [__r1],1
 00AE 5200              mov A,[X+0]
 00B0 0200              add A,[__r1]
 00B2 5300              mov [__r1],A
 00B4 5000              mov A,0
 00B6 0A00              adc A,[__r0]
 00B8 60D4              mov REG[0xd4],A
 00BA 3E00              mvi A,[__r1]
 00BC 5300              mov [__r0],A
 00BE 5207              mov A,[X+7]
 00C0 3A00              cmp A,[__r0]
 00C2 A014              jz L11
 00C4                   .dbline 133
 00C4           ;                       UART_CPutString(" FAIL\r\n");
 00C4                   .dbline 133
 00C4 10                push X
 00C5 5077              mov A,>L13
 00C7 08                push A
 00C8 5077              mov A,<L13
 00CA 5C                mov X,A
 00CB 18                pop A
 00CC 7C0000            xcall _UART_CPutString
 00CF 20                pop X
 00D0                   .dbline 134
 00D0           ;                       return(1);
 00D0 62D000            mov REG[0xd0],>__r0
 00D3 5001              mov A,1
 00D5 8021              xjmp L1
 00D7           L11:
 00D7                   .dbline 136
 00D7           ;               }
 00D7           ;       }
 00D7           L5:
 00D7                   .dbline 123
 00D7 7700              inc [X+0]
 00D9           L7:
 00D9                   .dbline 123
 00D9 3D0006            cmp [X+0],6
 00DC CF62              jc L4
 00DE           X1:
 00DE                   .dbline 137
 00DE           ;       UART_CPutString("\b\b\b\b\b PASS\r\n");
 00DE 10                push X
 00DF 506A              mov A,>L14
 00E1 08                push A
 00E2 506A              mov A,<L14
 00E4 5C                mov X,A
 00E5 18                pop A
 00E6 7C0000            xcall _UART_CPutString
 00E9 20                pop X
 00EA                   .dbline 139
 00EA           ;       // Place the SRAM back in Byte Mode
 00EA           ;       SPIRAM_WriteStatusRegister(SPIRAM_BYTE_MODE|SPIRAM_DISABLE_HOLD);
 00EA 5001              mov A,1
 00EC 08                push A
 00ED 7C0000            xcall _SPIRAM_WriteStatusRegister
 00F0 38FF              add SP,-1
 00F2 62D000            mov REG[0xd0],>__r0
 00F5                   .dbline 140
 00F5           ;       return(0);
 00F5 5000              mov A,0
 00F7                   .dbline -2
 00F7           L1:
 00F7 38F8              add SP,-8
 00F9 20                pop X
 00FA                   .dbline 0 ; func end
 00FA 7F                ret
 00FB                   .dbsym l status 7 c
 00FB                   .dbsym l mode 1 A[6:6]c
 00FB                   .dbsym l b 0 c
 00FB                   .dbend
 00FB                   .dbfunc e SPIRAM_ByteModeTest _SPIRAM_ByteModeTest fi
 00FB           ;         status -> X+4
 00FB           ;             in -> X+3
 00FB           ;           addr -> X+1
 00FB           ;              b -> X+0
 00FB           _SPIRAM_ByteModeTest::
 00FB                   .dbline -1
 00FB 10                push X
 00FC 4F                mov X,SP
 00FD 3805              add SP,5
 00FF                   .dbline 145
 00FF           ; }
 00FF           ; 
 00FF           ; // Test reading and writing the 23K256 in Byte Mode:
 00FF           ; WORD SPIRAM_ByteModeTest(void)
 00FF           ; {
 00FF                   .dbline 151
 00FF           ;       BYTE status;
 00FF           ;       BYTE b;
 00FF           ;       BYTE in;
 00FF           ;       WORD addr;
 00FF           ; 
 00FF           ;       SPIRAM_WriteStatusRegister(SPIRAM_BYTE_MODE|SPIRAM_DISABLE_HOLD);
 00FF 5001              mov A,1
 0101 08                push A
 0102 7C0000            xcall _SPIRAM_WriteStatusRegister
 0105 38FF              add SP,-1
 0107 62D000            mov REG[0xd0],>__r0
 010A                   .dbline 152
 010A           ;       UART_CPutString("      Byte Mode W/R Test: Addr 0x    ");
 010A 10                push X
 010B 5044              mov A,>L16
 010D 08                push A
 010E 5044              mov A,<L16
 0110 5C                mov X,A
 0111 18                pop A
 0112 7C0000            xcall _UART_CPutString
 0115 20                pop X
 0116                   .dbline 154
 0116           ; 
 0116           ;       for (addr=0; addr<0x8000 ; addr++) {
 0116 560200            mov [X+2],0
 0119 560100            mov [X+1],0
 011C 80BE              xjmp L20
 011E           L17:
 011E                   .dbline 154
 011E                   .dbline 155
 011E           ;               if (((addr-1) & 0x000f) == 0x000f) {
 011E 62D000            mov REG[0xd0],>__r0
 0121 5202              mov A,[X+2]
 0123 1101              sub A,1
 0125 5300              mov [__r1],A
 0127 5201              mov A,[X+1]
 0129 1900              sbb A,0
 012B 5300              mov [__r0],A
 012D 26000F            and [__r1],15
 0130 260000            and [__r0],0
 0133 B01D              jnz L21
 0135 3C000F            cmp [__r1],15
 0138 B018              jnz L21
 013A           X2:
 013A                   .dbline 156
 013A           ;                       UART_CPutString("\b\b\b\b");
 013A                   .dbline 156
 013A 10                push X
 013B 503F              mov A,>L23
 013D 08                push A
 013E 503F              mov A,<L23
 0140 5C                mov X,A
 0141 18                pop A
 0142 7C0000            xcall _UART_CPutString
 0145 20                pop X
 0146                   .dbline 157
 0146           ;                       UART_PutSHexInt(addr);
 0146 10                push X
 0147 5201              mov A,[X+1]
 0149 08                push A
 014A 5202              mov A,[X+2]
 014C 20                pop X
 014D 7C0000            xcall _UART_PutSHexInt
 0150 20                pop X
 0151                   .dbline 158
 0151           ;               }
 0151           L21:
 0151                   .dbline 159
 0151           ;               b = 0;
 0151 560000            mov [X+0],0
 0154           L24:
 0154                   .dbline 160
 0154           ;               do {
 0154                   .dbline 161
 0154           ;                       SPIRAM_WriteByte(addr, b);
 0154 5200              mov A,[X+0]
 0156 08                push A
 0157 5201              mov A,[X+1]
 0159 08                push A
 015A 5202              mov A,[X+2]
 015C 08                push A
 015D 7C0000            xcall _SPIRAM_WriteByte
 0160                   .dbline 162
 0160           ;                       in = SPIRAM_ReadByte(addr);
 0160 5201              mov A,[X+1]
 0162 08                push A
 0163 5202              mov A,[X+2]
 0165 08                push A
 0166 7C0000            xcall _SPIRAM_ReadByte
 0169 38FB              add SP,-5
 016B 62D000            mov REG[0xd0],>__r0
 016E 5403              mov [X+3],A
 0170                   .dbline 163
 0170           ;                       if (in != b) {
 0170 5203              mov A,[X+3]
 0172 3B00              cmp A,[X+0]
 0174 A02D              jz L27
 0176                   .dbline 164
 0176           ;                               UART_CPutString("\b\b\b\b");
 0176                   .dbline 164
 0176 10                push X
 0177 503F              mov A,>L23
 0179 08                push A
 017A 503F              mov A,<L23
 017C 5C                mov X,A
 017D 18                pop A
 017E 7C0000            xcall _UART_CPutString
 0181 20                pop X
 0182                   .dbline 165
 0182           ;                               UART_PutSHexInt(addr);
 0182 10                push X
 0183 5201              mov A,[X+1]
 0185 08                push A
 0186 5202              mov A,[X+2]
 0188 20                pop X
 0189 7C0000            xcall _UART_PutSHexInt
 018C                   .dbline 166
 018C           ;                               UART_CPutString(" FAIL\r\n");
 018C 5077              mov A,>L13
 018E 08                push A
 018F 5077              mov A,<L13
 0191 5C                mov X,A
 0192 18                pop A
 0193 7C0000            xcall _UART_CPutString
 0196 20                pop X
 0197                   .dbline 167
 0197           ;                               return(1);
 0197 62D000            mov REG[0xd0],>__r0
 019A 550001            mov [__r1],1
 019D 550000            mov [__r0],0
 01A0 8059              xjmp L15
 01A2           L27:
 01A2                   .dbline 169
 01A2           ;                       }
 01A2           ;                       if (!b)
 01A2 3D0000            cmp [X+0],0
 01A5 B006              jnz L29
 01A7                   .dbline 170
 01A7           ;                               b = 0x01;
 01A7 560001            mov [X+0],1
 01AA 8003              xjmp L30
 01AC           L29:
 01AC                   .dbline 172
 01AC           ;                       else
 01AC           ;                               b = b << 1;
 01AC 6600              asl [X+0]
 01AE           L30:
 01AE                   .dbline 173
 01AE           ;               } while(b);
 01AE           L25:
 01AE                   .dbline 173
 01AE 3D0000            cmp [X+0],0
 01B1 BFA2              jnz L24
 01B3                   .dbline 174
 01B3           ;               if (UART_cReadChar()) {
 01B3 10                push X
 01B4 7C0000            xcall _UART_cReadChar
 01B7 20                pop X
 01B8 62D000            mov REG[0xd0],>__r0
 01BB 3900              cmp A,0
 01BD A018              jz L31
 01BF                   .dbline 175
 01BF           ;                       UART_CPutString("\b\b\b\b\b\b\b\b\b\b\b\b ABORTED    \r\n");
 01BF                   .dbline 175
 01BF 10                push X
 01C0 5024              mov A,>L33
 01C2 08                push A
 01C3 5024              mov A,<L33
 01C5 5C                mov X,A
 01C6 18                pop A
 01C7 7C0000            xcall _UART_CPutString
 01CA 20                pop X
 01CB                   .dbline 176
 01CB           ;                       return(0);
 01CB 62D000            mov REG[0xd0],>__r0
 01CE 550000            mov [__r1],0
 01D1 550000            mov [__r0],0
 01D4 8025              xjmp L15
 01D6           L31:
 01D6                   .dbline 178
 01D6           ;               }
 01D6           ;       }
 01D6           L18:
 01D6                   .dbline 154
 01D6 7702              inc [X+2]
 01D8 0F0100            adc [X+1],0
 01DB           L20:
 01DB                   .dbline 154
 01DB 5202              mov A,[X+2]
 01DD 1100              sub A,0
 01DF 5201              mov A,[X+1]
 01E1 1980              sbb A,-128
 01E3 CF3A              jc L17
 01E5           X3:
 01E5                   .dbline 179
 01E5           ;       UART_CPutString("\b\b\b\b\b\b\b\b\b\b\b\b PASS       \r\n");
 01E5 10                push X
 01E6 5009              mov A,>L34
 01E8 08                push A
 01E9 5009              mov A,<L34
 01EB 5C                mov X,A
 01EC 18                pop A
 01ED 7C0000            xcall _UART_CPutString
 01F0 20                pop X
 01F1                   .dbline 180
 01F1           ;       return(0);
 01F1 62D000            mov REG[0xd0],>__r0
 01F4 550000            mov [__r1],0
 01F7 550000            mov [__r0],0
 01FA                   .dbline -2
 01FA           L15:
 01FA 38FB              add SP,-5
 01FC 20                pop X
 01FD                   .dbline 0 ; func end
 01FD 7F                ret
 01FE                   .dbsym l status 4 c
 01FE                   .dbsym l in 3 c
 01FE                   .dbsym l addr 1 i
 01FE                   .dbsym l b 0 c
 01FE                   .dbend
 01FE                   .dbfunc e SPIRAM_SequentialModeTest _SPIRAM_SequentialModeTest fi
 01FE           ;             in -> X+5
 01FE           ;         status -> X+4
 01FE           ;           addr -> X+2
 01FE           ;              b -> X+1
 01FE           ;              a -> X+0
 01FE           _SPIRAM_SequentialModeTest::
 01FE                   .dbline -1
 01FE 10                push X
 01FF 4F                mov X,SP
 0200 3806              add SP,6
 0202                   .dbline 185
 0202           ; }
 0202           ; 
 0202           ; // Test reading and writing the 23K256 in Sequential Mode:
 0202           ; WORD SPIRAM_SequentialModeTest(void)
 0202           ; {
 0202                   .dbline 192
 0202           ;       BYTE status;
 0202           ;       BYTE a;
 0202           ;       BYTE b;
 0202           ;       BYTE in;
 0202           ;       WORD addr;
 0202           ; 
 0202           ;       SPIRAM_WriteStatusRegister(SPIRAM_SEQUENTIAL_MODE|SPIRAM_DISABLE_HOLD);
 0202 5041              mov A,65
 0204 08                push A
 0205 7C0000            xcall _SPIRAM_WriteStatusRegister
 0208 38FF              add SP,-1
 020A 62D000            mov REG[0xd0],>__r0
 020D                   .dbline 193
 020D           ;       UART_CPutString("Sequential Mode W/R Test: Addr 0x    ");
 020D 10                push X
 020E 50E3              mov A,>L36
 0210 08                push A
 0211 50E3              mov A,<L36
 0213 5C                mov X,A
 0214 18                pop A
 0215 7C0000            xcall _UART_CPutString
 0218 20                pop X
 0219                   .dbline 195
 0219           ; 
 0219           ;       for (addr=0; addr<0x8000 ; addr+=ARRAY_SIZE) {
 0219 560300            mov [X+3],0
 021C 560200            mov [X+2],0
 021F 8103              xjmp L40
 0221           L37:
 0221                   .dbline 195
 0221                   .dbline 196
 0221           ;               UART_CPutString("\b\b\b\b");
 0221 10                push X
 0222 503F              mov A,>L23
 0224 08                push A
 0225 503F              mov A,<L23
 0227 5C                mov X,A
 0228 18                pop A
 0229 7C0000            xcall _UART_CPutString
 022C 20                pop X
 022D                   .dbline 197
 022D           ;               UART_PutSHexInt(addr);
 022D 10                push X
 022E 5202              mov A,[X+2]
 0230 08                push A
 0231 5203              mov A,[X+3]
 0233 20                pop X
 0234 7C0000            xcall _UART_PutSHexInt
 0237 20                pop X
 0238                   .dbline 198
 0238           ;               b = 0;
 0238 560100            mov [X+1],0
 023B           L41:
 023B                   .dbline 199
 023B           ;               do {
 023B                   .dbline 200
 023B           ;                       for (a=0 ; a<ARRAY_SIZE ; a++) {
 023B 560000            mov [X+0],0
 023E 801B              xjmp L47
 0240           L44:
 0240                   .dbline 200
 0240                   .dbline 201
 0240           ;                               DataOut[a] = b;
 0240 62D000            mov REG[0xd0],>__r0
 0243 5200              mov A,[X+0]
 0245 5300              mov [__r1],A
 0247 550000            mov [__r0],0
 024A 060000            add [__r1],<_DataOut
 024D 0E0000            adc [__r0],>_DataOut
 0250 5100              mov A,[__r0]
 0252 60D5              mov REG[0xd5],A
 0254 5201              mov A,[X+1]
 0256 3F00              mvi [__r1],A
 0258                   .dbline 202
 0258           ;                       }
 0258           L45:
 0258                   .dbline 200
 0258 7700              inc [X+0]
 025A           L47:
 025A                   .dbline 200
 025A 3D0040            cmp [X+0],64
 025D CFE2              jc L44
 025F           X4:
 025F                   .dbline 203
 025F           ;                       SPIRAM_WriteArray(addr, DataOut, ARRAY_SIZE);
 025F 5040              mov A,64
 0261 08                push A
 0262 5000              mov A,>_DataOut
 0264 08                push A
 0265 5000              mov A,<_DataOut
 0267 08                push A
 0268 5202              mov A,[X+2]
 026A 08                push A
 026B 5203              mov A,[X+3]
 026D 08                push A
 026E 7C0000            xcall _SPIRAM_WriteArray
 0271                   .dbline 204
 0271           ;                       SPIRAM_ReadArray(addr, DataIn, ARRAY_SIZE);
 0271 5040              mov A,64
 0273 08                push A
 0274 5000              mov A,>_DataIn
 0276 08                push A
 0277 5000              mov A,<_DataIn
 0279 08                push A
 027A 5202              mov A,[X+2]
 027C 08                push A
 027D 5203              mov A,[X+3]
 027F 08                push A
 0280 7C0000            xcall _SPIRAM_ReadArray
 0283 38F6              add SP,-10
 0285                   .dbline 205
 0285           ;                       for (a=0 ; a<ARRAY_SIZE ; a++) {
 0285 560000            mov [X+0],0
 0288 805B              xjmp L51
 028A           L48:
 028A                   .dbline 205
 028A                   .dbline 206
 028A           ;                               if (DataIn[a] != b) {
 028A 62D000            mov REG[0xd0],>__r0
 028D 5200              mov A,[X+0]
 028F 5300              mov [__r1],A
 0291 550000            mov [__r0],0
 0294 060000            add [__r1],<_DataIn
 0297 0E0000            adc [__r0],>_DataIn
 029A 5100              mov A,[__r0]
 029C 60D4              mov REG[0xd4],A
 029E 3E00              mvi A,[__r1]
 02A0 3B01              cmp A,[X+1]
 02A2 A03F              jz L52
 02A4                   .dbline 207
 02A4           ;                                       UART_CPutString("\b\b\b\b");
 02A4                   .dbline 207
 02A4 10                push X
 02A5 503F              mov A,>L23
 02A7 08                push A
 02A8 503F              mov A,<L23
 02AA 5C                mov X,A
 02AB 18                pop A
 02AC 7C0000            xcall _UART_CPutString
 02AF 20                pop X
 02B0                   .dbline 208
 02B0           ;                                       UART_PutSHexInt(addr+a);
 02B0 62D000            mov REG[0xd0],>__r0
 02B3 5200              mov A,[X+0]
 02B5 5300              mov [__r1],A
 02B7 550000            mov [__r0],0
 02BA 5203              mov A,[X+3]
 02BC 0200              add A,[__r1]
 02BE 5300              mov [__r1],A
 02C0 5202              mov A,[X+2]
 02C2 0A00              adc A,[__r0]
 02C4 10                push X
 02C5 08                push A
 02C6 5100              mov A,[__r1]
 02C8 20                pop X
 02C9 7C0000            xcall _UART_PutSHexInt
 02CC                   .dbline 209
 02CC           ;                                       UART_CPutString(" FAIL\r\n");
 02CC 5077              mov A,>L13
 02CE 08                push A
 02CF 5077              mov A,<L13
 02D1 5C                mov X,A
 02D2 18                pop A
 02D3 7C0000            xcall _UART_CPutString
 02D6 20                pop X
 02D7                   .dbline 210
 02D7           ;                                       return(1);
 02D7 62D000            mov REG[0xd0],>__r0
 02DA 550001            mov [__r1],1
 02DD 550000            mov [__r0],0
 02E0 8061              xjmp L35
 02E2           L52:
 02E2                   .dbline 212
 02E2           ;                               }
 02E2           ;                       }
 02E2           L49:
 02E2                   .dbline 205
 02E2 7700              inc [X+0]
 02E4           L51:
 02E4                   .dbline 205
 02E4 3D0040            cmp [X+0],64
 02E7 CFA2              jc L48
 02E9           X5:
 02E9                   .dbline 213
 02E9           ;                       if (!b)
 02E9 3D0100            cmp [X+1],0
 02EC B006              jnz L54
 02EE                   .dbline 214
 02EE           ;                               b = 0x01;
 02EE 560101            mov [X+1],1
 02F1 8003              xjmp L55
 02F3           L54:
 02F3                   .dbline 216
 02F3           ;                       else
 02F3           ;                               b = b << 1;
 02F3 6601              asl [X+1]
 02F5           L55:
 02F5                   .dbline 217
 02F5           ;               } while(b);
 02F5           L42:
 02F5                   .dbline 217
 02F5 3D0100            cmp [X+1],0
 02F8 BF42              jnz L41
 02FA                   .dbline 218
 02FA           ;               if (UART_cReadChar()) {
 02FA 10                push X
 02FB 7C0000            xcall _UART_cReadChar
 02FE 20                pop X
 02FF 62D000            mov REG[0xd0],>__r0
 0302 3900              cmp A,0
 0304 A018              jz L56
 0306                   .dbline 219
 0306           ;                       UART_CPutString("\b\b\b\b\b\b\b\b\b\b\b\b ABORTED    \r\n");
 0306                   .dbline 219
 0306 10                push X
 0307 5024              mov A,>L33
 0309 08                push A
 030A 5024              mov A,<L33
 030C 5C                mov X,A
 030D 18                pop A
 030E 7C0000            xcall _UART_CPutString
 0311 20                pop X
 0312                   .dbline 220
 0312           ;                       return(0);
 0312 62D000            mov REG[0xd0],>__r0
 0315 550000            mov [__r1],0
 0318 550000            mov [__r0],0
 031B 8026              xjmp L35
 031D           L56:
 031D                   .dbline 222
 031D           ;               }
 031D           ;       }
 031D           L38:
 031D                   .dbline 195
 031D 070340            add [X+3],64
 0320 0F0200            adc [X+2],0
 0323           L40:
 0323                   .dbline 195
 0323 5203              mov A,[X+3]
 0325 1100              sub A,0
 0327 5202              mov A,[X+2]
 0329 1980              sbb A,-128
 032B CEF5              jc L37
 032D           X6:
 032D                   .dbline 223
 032D           ;       UART_CPutString("\b\b\b\b\b\b\b\b\b\b\b\b PASS       \r\n");
 032D 10                push X
 032E 5009              mov A,>L34
 0330 08                push A
 0331 5009              mov A,<L34
 0333 5C                mov X,A
 0334 18                pop A
 0335 7C0000            xcall _UART_CPutString
 0338 20                pop X
 0339                   .dbline 224
 0339           ;       return(0);
 0339 62D000            mov REG[0xd0],>__r0
 033C 550000            mov [__r1],0
 033F 550000            mov [__r0],0
 0342                   .dbline -2
 0342           L35:
 0342 38FA              add SP,-6
 0344 20                pop X
 0345                   .dbline 0 ; func end
 0345 7F                ret
 0346                   .dbsym l in 5 c
 0346                   .dbsym l status 4 c
 0346                   .dbsym l addr 2 i
 0346                   .dbsym l b 1 c
 0346                   .dbsym l a 0 c
 0346                   .dbend
 0346                   .dbfunc e GetNumber _GetNumber fc
 0346           ;              c -> X+0
 0346           ;            max -> X-5
 0346           ;            min -> X-4
 0346           _GetNumber::
 0346                   .dbline -1
 0346 10                push X
 0347 4F                mov X,SP
 0348 3801              add SP,1
 034A                   .dbline 230
 034A           ; }
 034A           ; 
 034A           ; // This function reads characters from the serial until a character is entered that is within the min & max ASCII characters.
 034A           ; // That character is returned
 034A           ; char GetNumber(char min, char max)
 034A           ; {
 034A 8034              xjmp L60
 034C           L59:
 034C                   .dbline 234
 034C           ;       char c;
 034C           ;       
 034C           ;       while (1)
 034C           ;       {
 034C                   .dbline 235
 034C           ;               c = UART_cReadChar(); // Read the character
 034C 10                push X
 034D 7C0000            xcall _UART_cReadChar
 0350 20                pop X
 0351 62D000            mov REG[0xd0],>__r0
 0354 5400              mov [X+0],A
 0356                   .dbline 236
 0356           ;               if (c < ('0' + min) || c > ('0' + max)) // If the character is not within min to max range, continue the loop
 0356 52FC              mov A,[X-4]
 0358 0130              add A,48
 035A 5300              mov [__r0],A
 035C 5200              mov A,[X+0]
 035E 3A00              cmp A,[__r0]
 0360 C00C              jc L64
 0362           X8:
 0362 62D000            mov REG[0xd0],>__r0
 0365 52FB              mov A,[X-5]
 0367 0130              add A,48
 0369 3B00              cmp A,[X+0]
 036B D003              jnc L62
 036D           X9:
 036D           L64:
 036D                   .dbline 237
 036D           ;                       continue;
 036D 8011              xjmp L60
 036F           L62:
 036F                   .dbline 239
 036F           ;               
 036F           ;               UART_PutChar(c); // Put the character on the serial
 036F 10                push X
 0370 5200              mov A,[X+0]
 0372 7C0000            xcall _UART_PutChar
 0375 20                pop X
 0376                   .dbline 240
 0376           ;               return (c - '0'); // This returns the integer number entered instead of the ASCII value
 0376 62D000            mov REG[0xd0],>__r0
 0379 5200              mov A,[X+0]
 037B 1130              sub A,48
 037D 8003              xjmp L58
 037F           L60:
 037F                   .dbline 233
 037F 8FCC              xjmp L59
 0381           X7:
 0381                   .dbline -2
 0381           L58:
 0381 38FF              add SP,-1
 0383 20                pop X
 0384                   .dbline 0 ; func end
 0384 7F                ret
 0385                   .dbsym l c 0 c
 0385                   .dbsym l max -5 c
 0385                   .dbsym l min -4 c
 0385                   .dbend
 0385                   .dbfunc e PlayBlock _PlayBlock fV
 0385           ;      startAddr -> X+4
 0385           ;        endAddr -> X+2
 0385           ;           addr -> X+0
 0385           ;             id -> X-4
 0385           _PlayBlock::
 0385                   .dbline -1
 0385 10                push X
 0386 4F                mov X,SP
 0387 3806              add SP,6
 0389                   .dbline 248
 0389           ;       }
 0389           ;       
 0389           ;       return 0;
 0389           ; }
 0389           ; 
 0389           ; // This function plays a block of data where opt is the data block 0-3.
 0389           ; void PlayBlock(char id)
 0389           ; {     
 0389                   .dbline 249
 0389           ;       WORD startAddr = id * 0x2000; // Where the address starts for block
 0389 62D000            mov REG[0xd0],>__r0
 038C 52FC              mov A,[X-4]
 038E 5300              mov [__r0],A
 0390 550000            mov [__r1],0
 0393 6500              asl [__r0]
 0395 6500              asl [__r1]
 0397 6B00              rlc [__r0]
 0399 6500              asl [__r1]
 039B 6B00              rlc [__r0]
 039D 6500              asl [__r1]
 039F 6B00              rlc [__r0]
 03A1 6500              asl [__r1]
 03A3 6B00              rlc [__r0]
 03A5 5100              mov A,[__r1]
 03A7 5405              mov [X+5],A
 03A9 5100              mov A,[__r0]
 03AB 5404              mov [X+4],A
 03AD                   .dbline 250
 03AD           ;       WORD endAddr = startAddr + 0x2000; // Where the address ends for block
 03AD 5205              mov A,[X+5]
 03AF 0100              add A,0
 03B1 5403              mov [X+3],A
 03B3 5204              mov A,[X+4]
 03B5 0920              adc A,32
 03B7 5402              mov [X+2],A
 03B9                   .dbline 253
 03B9           ;       WORD addr;
 03B9           ;       
 03B9           ;       SPIRAM_WriteStatusRegister(SPIRAM_BYTE_MODE | SPIRAM_DISABLE_HOLD);
 03B9 5001              mov A,1
 03BB 08                push A
 03BC 7C0000            xcall _SPIRAM_WriteStatusRegister
 03BF 38FF              add SP,-1
 03C1 62D000            mov REG[0xd0],>__r0
 03C4                   .dbline 254
 03C4           ;       for (addr = startAddr; addr < endAddr; addr++)
 03C4 5205              mov A,[X+5]
 03C6 5401              mov [X+1],A
 03C8 5204              mov A,[X+4]
 03CA 5400              mov [X+0],A
 03CC 8019              xjmp L69
 03CE           L66:
 03CE                   .dbline 255
 03CE           ;               DAC8_WriteStall(SPIRAM_ReadByte(addr));
 03CE 5200              mov A,[X+0]
 03D0 08                push A
 03D1 5201              mov A,[X+1]
 03D3 08                push A
 03D4 7C0000            xcall _SPIRAM_ReadByte
 03D7 38FE              add SP,-2
 03D9 62D000            mov REG[0xd0],>__r0
 03DC 10                push X
 03DD 7C0000            xcall _DAC8_WriteStall
 03E0 20                pop X
 03E1           L67:
 03E1                   .dbline 254
 03E1 7701              inc [X+1]
 03E3 0F0000            adc [X+0],0
 03E6           L69:
 03E6                   .dbline 254
 03E6 5201              mov A,[X+1]
 03E8 1303              sub A,[X+3]
 03EA 5200              mov A,[X+0]
 03EC 1B02              sbb A,[X+2]
 03EE CFDF              jc L66
 03F0           X10:
 03F0                   .dbline -2
 03F0           L65:
 03F0 38FA              add SP,-6
 03F2 20                pop X
 03F3                   .dbline 0 ; func end
 03F3 7F                ret
 03F4                   .dbsym l startAddr 4 i
 03F4                   .dbsym l endAddr 2 i
 03F4                   .dbsym l addr 0 i
 03F4                   .dbsym l id -4 c
 03F4                   .dbend
 03F4                   .dbfunc e main _main fV
 03F4           ;            opt -> X+0
 03F4           _main::
 03F4                   .dbline -1
 03F4 10                push X
 03F5 4F                mov X,SP
 03F6 3803              add SP,3
 03F8                   .dbline 259
 03F8           ; }
 03F8           ; 
 03F8           ; void main(void)
 03F8           ; {
 03F8                   .dbline 263
 03F8           ;       char opt;
 03F8           ;       
 03F8           ;       // Make sure nCS is high before doing anything
 03F8           ;       nCS_HIGH;
 03F8                   .dbline 263
 03F8 430404            or REG[0x4],4
 03FB                   .dbline 263
 03FB                   .dbline 263
 03FB                   .dbline 266
 03FB           ;       
 03FB           ;       // Enable user module interrupts
 03FB           ;       SleepTimer_EnableInt();
 03FB 10                push X
 03FC 7C0000            xcall _SleepTimer_EnableInt
 03FF 20                pop X
 0400                   .dbline 269
 0400           ; 
 0400           ;       // Enable global interrutps
 0400           ;       M8C_EnableGInt;
 0400 7101                      or  F, 01h
 0402           
 0402                   .dbline 272
 0402           ; 
 0402           ;       // Start the user modules
 0402           ;       UART_Start(UART_PARITY_NONE);
 0402 10                push X
 0403 5000              mov A,0
 0405 7C0000            xcall _UART_Start
 0408                   .dbline 273
 0408           ;       UART_PutCRLF();
 0408 7C0000            xcall _UART_PutCRLF
 040B                   .dbline 274
 040B           ;       SPIM_Start(SPIM_SPIM_MODE_0 | SPIM_SPIM_MSB_FIRST);
 040B 5000              mov A,0
 040D 7C0000            xcall _SPIM_Start
 0410                   .dbline 275
 0410           ;       SleepTimer_Start();
 0410 7C0000            xcall _SleepTimer_Start
 0413                   .dbline 276
 0413           ;       DAC8_Start(DAC8_FULLPOWER);
 0413 5003              mov A,3
 0415 7C0000            xcall _DAC8_Start
 0418 20                pop X
 0419 8092              xjmp L72
 041B           L71:
 041B                   .dbline 279
 041B           ; 
 041B           ;       while(1) 
 041B           ;       {
 041B                   .dbline 280
 041B           ;               UART_CPutString("Synthetic wave output is on Port0[4]\r\nCowabunga Dude! Time to catch some waves.\r\n\r\n0. Play block 0\r\n1. Play block 1\r\n2. Play block 2\r\n3. Play block 3\r\n4. Test status register\r\n5. Test byte mode\r\n6. Test sequential mode\r\n");
 041B 10                push X
 041C 5006              mov A,>L74
 041E 08                push A
 041F 5006              mov A,<L74
 0421 5C                mov X,A
 0422 18                pop A
 0423 7C0000            xcall _UART_CPutString
 0426 20                pop X
 0427                   .dbline 282
 0427           ;               
 0427           ;               opt = GetNumber(0, 6);
 0427 5006              mov A,6
 0429 08                push A
 042A 5000              mov A,0
 042C 08                push A
 042D 9F17              xcall _GetNumber
 042F 38FE              add SP,-2
 0431 62D000            mov REG[0xd0],>__r0
 0434 5400              mov [X+0],A
 0436                   .dbline 283
 0436           ;               switch (opt)
 0436 5200              mov A,[X+0]
 0438 5402              mov [X+2],A
 043A 560100            mov [X+1],0
 043D 3D0100            cmp [X+1],0
 0440 B006              jnz X12
 0442 3D0204            cmp [X+2],4
 0445 A020              jz L80
 0447           X12:
 0447 3D0100            cmp [X+1],0
 044A B006              jnz X13
 044C 3D0205            cmp [X+2],5
 044F A02A              jz L84
 0451           X13:
 0451 3D0100            cmp [X+1],0
 0454 B006              jnz X14
 0456 3D0206            cmp [X+2],6
 0459 A03A              jz L88
 045B           X14:
 045B 8049              xjmp L75
 045D           L79:
 045D                   .dbline 287
 045D           ;               {
 045D           ;                       case 4:
 045D           ;                               while(SPIRAM_StatusRegisterTest()) 
 045D           ;                                       SleepTimer_SyncWait(4, SleepTimer_WAIT_RELOAD);
 045D 10                push X
 045E 5700              mov X,0
 0460 5004              mov A,4
 0462 7C0000            xcall _SleepTimer_SyncWait
 0465 20                pop X
 0466           L80:
 0466                   .dbline 286
 0466 9B98              xcall _SPIRAM_StatusRegisterTest
 0468 62D000            mov REG[0xd0],>__r0
 046B 3900              cmp A,0
 046D BFEF              jnz L79
 046F                   .dbline 288
 046F           ;                               break;
 046F 803C              xjmp L76
 0471           L83:
 0471                   .dbline 292
 0471           ;                       
 0471           ;                       case 5:
 0471           ;                               while(SPIRAM_ByteModeTest()) 
 0471           ;                                       SleepTimer_SyncWait(4, SleepTimer_WAIT_RELOAD); 
 0471 10                push X
 0472 5700              mov X,0
 0474 5004              mov A,4
 0476 7C0000            xcall _SleepTimer_SyncWait
 0479 20                pop X
 047A           L84:
 047A                   .dbline 291
 047A 9C7F              xcall _SPIRAM_ByteModeTest
 047C 62D000            mov REG[0xd0],>__r0
 047F 3C0000            cmp [__r0],0
 0482 BFEE              jnz L83
 0484 3C0000            cmp [__r1],0
 0487 BFE9              jnz L83
 0489           X15:
 0489                   .dbline 293
 0489           ;                               break;
 0489 8022              xjmp L76
 048B           L87:
 048B                   .dbline 297
 048B           ;                       
 048B           ;                       case 6:
 048B           ;                               while(SPIRAM_SequentialModeTest()) 
 048B           ;                                       SleepTimer_SyncWait(4, SleepTimer_WAIT_RELOAD);
 048B 10                push X
 048C 5700              mov X,0
 048E 5004              mov A,4
 0490 7C0000            xcall _SleepTimer_SyncWait
 0493 20                pop X
 0494           L88:
 0494                   .dbline 296
 0494 9D68              xcall _SPIRAM_SequentialModeTest
 0496 62D000            mov REG[0xd0],>__r0
 0499 3C0000            cmp [__r0],0
 049C BFEE              jnz L87
 049E 3C0000            cmp [__r1],0
 04A1 BFE9              jnz L87
 04A3           X16:
 04A3                   .dbline 298
 04A3           ;                               break;
 04A3 8008              xjmp L76
 04A5           L75:
 04A5                   .dbline 301
 04A5           ;                       
 04A5           ;                       default:
 04A5           ;                               PlayBlock(opt);
 04A5 5200              mov A,[X+0]
 04A7 08                push A
 04A8 9EDB              xcall _PlayBlock
 04AA 38FF              add SP,-1
 04AC                   .dbline 302
 04AC           ;                               break;  
 04AC           L76:
 04AC                   .dbline 304
 04AC           ;               }
 04AC           ;       }
 04AC           L72:
 04AC                   .dbline 278
 04AC 8F6E              xjmp L71
 04AE           X11:
 04AE                   .dbline -2
 04AE           L70:
 04AE 38FD              add SP,-3
 04B0 20                pop X
 04B1                   .dbline 0 ; func end
 04B1 8FFF              jmp .
 04B3                   .dbsym l opt 0 c
 04B3                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\SPI_SRAM\SPI_SRAM\main.c
 0000           _DataOut::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 00000000          .byte 0,0,0,0
 0040                   .dbsym e DataOut _DataOut A[64:64]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\SPI_SRAM\SPI_SRAM\main.c
 0000           _DataIn::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 00000000          .byte 0,0,0,0
 0040                   .dbsym e DataIn _DataIn A[64:64]c
                        .area lit(rom, con, rel, lit)
 0006           L74:
 0006 53796E7468657469632077617665206F  .byte 'S,'y,'n,'t,'h,'e,'t,'i,'c,32,'w,'a,'v,'e,32,'o
 0016 7574707574206973206F6E20506F7274  .byte 'u,'t,'p,'u,'t,32,'i,'s,32,'o,'n,32,'P,'o,'r,'t
 0026 305B345D0D0A436F776162756E676120  .byte 48,91,52,93,13,10,'C,'o,'w,'a,'b,'u,'n,'g,'a,32
 0036 44756465212054696D6520746F206361  .byte 'D,'u,'d,'e,33,32,'T,'i,'m,'e,32,'t,'o,32,'c,'a
 0046 74636820736F6D652077617665732E0D  .byte 't,'c,'h,32,'s,'o,'m,'e,32,'w,'a,'v,'e,'s,46,13
 0056 0A0D0A302E20506C617920626C6F636B  .byte 10,13,10,48,46,32,'P,'l,'a,'y,32,'b,'l,'o,'c,'k
 0066 20300D0A312E20506C617920626C6F63  .byte 32,48,13,10,49,46,32,'P,'l,'a,'y,32,'b,'l,'o,'c
 0076 6B20310D0A322E20506C617920626C6F  .byte 'k,32,49,13,10,50,46,32,'P,'l,'a,'y,32,'b,'l,'o
 0086 636B20320D0A332E20506C617920626C  .byte 'c,'k,32,50,13,10,51,46,32,'P,'l,'a,'y,32,'b,'l
 0096 6F636B20330D0A342E20546573742073  .byte 'o,'c,'k,32,51,13,10,52,46,32,'T,'e,'s,'t,32,'s
 00A6 74617475732072656769737465720D0A  .byte 't,'a,'t,'u,'s,32,'r,'e,'g,'i,'s,'t,'e,'r,13,10
 00B6 352E20546573742062797465206D6F64  .byte 53,46,32,'T,'e,'s,'t,32,'b,'y,'t,'e,32,'m,'o,'d
 00C6 650D0A362E2054657374207365717565  .byte 'e,13,10,54,46,32,'T,'e,'s,'t,32,'s,'e,'q,'u,'e
 00D6 6E7469616C206D6F64650D0A00        .byte 'n,'t,'i,'a,'l,32,'m,'o,'d,'e,13,10,0
 00E3           L36:
 00E3 53657175656E7469616C204D6F646520  .byte 'S,'e,'q,'u,'e,'n,'t,'i,'a,'l,32,'M,'o,'d,'e,32
 00F3 572F5220546573743A20416464722030  .byte 'W,47,'R,32,'T,'e,'s,'t,58,32,'A,'d,'d,'r,32,48
 0103 782020202000      .byte 'x,32,32,32,32,0
 0109           L34:
 0109 08080808080808080808080820504153  .byte 8,8,8,8,8,8,8,8,8,8,8,8,32,'P,'A,'S
 0119 53202020202020200D0A00    .byte 'S,32,32,32,32,32,32,32,13,10,0
 0124           L33:
 0124 0808080808080808080808082041424F  .byte 8,8,8,8,8,8,8,8,8,8,8,8,32,'A,'B,'O
 0134 52544544202020200D0A00    .byte 'R,'T,'E,'D,32,32,32,32,13,10,0
 013F           L23:
 013F 0808080800        .byte 8,8,8,8,0
 0144           L16:
 0144 20202020202042797465204D6F646520  .byte 32,32,32,32,32,32,'B,'y,'t,'e,32,'M,'o,'d,'e,32
 0154 572F5220546573743A20416464722030  .byte 'W,47,'R,32,'T,'e,'s,'t,58,32,'A,'d,'d,'r,32,48
 0164 782020202000      .byte 'x,32,32,32,32,0
 016A           L14:
 016A 080808080820504153530D0A00        .byte 8,8,8,8,8,32,'P,'A,'S,'S,13,10,0
 0177           L13:
 0177 204641494C0D0A00  .byte 32,'F,'A,'I,'L,13,10,0
 017F           L10:
 017F 0D0A5772697465206F6620696E76616C  .byte 13,10,'W,'r,'i,'t,'e,32,'o,'f,32,'i,'n,'v,'a,'l
 018F 69642053746174757320526567697374  .byte 'i,'d,32,'S,'t,'a,'t,'u,'s,32,'R,'e,'g,'i,'s,'t
 019F 65722076616C75652E2053797374656D  .byte 'e,'r,32,'v,'a,'l,'u,'e,46,32,'S,'y,'s,'t,'e,'m
 01AF 2068616C7465642E0D0A00    .byte 32,'h,'a,'l,'t,'e,'d,46,13,10,0
 01BA           L3:
 01BA 53746174757320526567697374657220  .byte 'S,'t,'a,'t,'u,'s,32,'R,'e,'g,'i,'s,'t,'e,'r,32
 01CA 572F5220546573743A203078202000    .byte 'W,47,'R,32,'T,'e,'s,'t,58,32,48,'x,32,32,0
