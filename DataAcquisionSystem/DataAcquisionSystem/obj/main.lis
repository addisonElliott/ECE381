 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _DACUpdateDone::
 0000 00                .byte 0
 0001                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0001                   .dbsym e DACUpdateDone _DACUpdateDone c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0000           _chAMemBlk::
 0000 FF                .byte 255
 0001                   .dbsym e chAMemBlk _chAMemBlk c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0000           _chBMemBlk::
 0000 FF                .byte 255
 0001                   .dbsym e chBMemBlk _chBMemBlk c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0000           _triggerAddress::
 0000 0000              .word 0
 0002                   .dbsym e triggerAddress _triggerAddress I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0000           L2:
 0000 0820              .byte 8,32
 0002 0800              .byte 8,0
                        .area text(rom, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0000                   .dbfunc e GetLine _GetLine fV
 0000                   .dbsym s rubout L2 A[4:4]c
 0000           ;         strPos -> X+1
 0000           ;              c -> X+0
 0000           ;      bufferLen -> X-6
 0000           ;         buffer -> X-5
 0000           _GetLine::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3802              add SP,2
 0004                   .dbline 105
 0004           ; //----------------------------------------------------------------------------
 0004           ; // SPI SRAM Test Program
 0004           ; //
 0004           ; // PSoC Global Resources:
 0004           ; //   Power Setting     5.0V/24MHz
 0004           ; //   CPU_Clock         SysClk/1
 0004           ; //   32K_Select        Internal
 0004           ; //   PLL_Mode          Off
 0004           ; //   Sleep_Timer       8_Hz
 0004           ; //   VC1=SysClk/N     *4
 0004           ; //   VC2=VC1/N        *2
 0004           ; //                    *VC1 makes 6MHz SPIM Clock; VC2 makes 3MHz DAC Clock
 0004           ; //   VC3_Source        SysClk/1
 0004           ; //   VC3 Divider      *52
 0004           ; //                    *Used to set UART baud rate to 57600
 0004           ; //   SysClk Source     Internal
 0004           ; //   SysClk*2 Disable  { Any }
 0004           ; //   Analog Power      { Any }
 0004           ; //   Ref Mux           { Any }
 0004           ; //   AGndBypass        { Any }
 0004           ; //   Op-Amp Bias       { Any }
 0004           ; //   A_Buff_Power      { Any }
 0004           ; //   SwitchModePump    OFF
 0004           ; //   Trip Voltage      { Any }
 0004           ; //   LVD ThrottleBack *Disable
 0004           ; //                    *When enabled, an LVD event forces the CPU Clock to SysClk/8.
 0004           ; //   Watchdog Enable  *{ Any }
 0004           ; //                    *Incautious use of the Watchdog may adversely affect timing
 0004           ; //
 0004           ; // SPIM Parameters
 0004           ; //   Name              SPIM
 0004           ; //   Clock            *VC1
 0004           ; //                    *6MHz = 3Mbps SPI bit rate.
 0004           ; //   MISO              Row_2_Input_1
 0004           ; //   MOSI              Row_2_Output_0
 0004           ; //   SClk              Row_2_Output_3
 0004           ; //   Interrupt Mode    TXRegEmpty
 0004           ; //   ClockSync         Sync to SysClk
 0004           ; //   InvertMISO        Normal
 0004           ; //
 0004           ; // SPIM Module Notes
 0004           ; //  -The 23K256 SPI SRAM has a maximum clock speed of 20MHz
 0004           ; //   SPIM Clock must be set to two times the desired bit rate.
 0004           ; //  -This uses VC1 = SysClk/4 = 6MHz, yielding a bit rate of 3Mbps.
 0004           ; //  -Per SPIM Module datasheet, for SPI clocks greater than 1MHz,
 0004           ; //   the Row Input synchronization for the MISO signal should be
 0004           ; //   set to Async.
 0004           ; //  -PSoC 5V to 23K256 3.3V translation is accomplished by setting
 0004           ; //   all PSoC SPIM outputs to Open Drain Low drive mode and then
 0004           ; //   using 470ohm pull-up resistors. For 3MHz signals, a smaller
 0004           ; //   value resistor must be used to allow sufficient rise-time.
 0004           ; //  -Pinout:
 0004           ; //   CS   = P12 (StdCPU:    Open Drain Low)
 0004           ; //   SCLK = P13 (GlobalOut: Open Drain Low)
 0004           ; //   MOSI = P14 (GlobalOut: Open Drain Low)
 0004           ; //   MISO = P15 (GlobalIn:  High Z)
 0004           ; //
 0004           ; // DAC Module Notes
 0004           ; //  -To maximize the output sample rate, this example operates the
 0004           ; //   DACs at their maximum practical speed of 3MHz which is provided
 0004           ; //   by VC2. The Analog Column Clock MUXs for both DAC must have
 0004           ; //   VC2 selected manually in the [Chip] view.
 0004           ; //  -DAC8_WriteStall() should be used and not DAC8_WriteBlind in
 0004           ; //   order to prevent output glitches during the DAC update.
 0004           ; //
 0004           ; // bnoble@siue.edu 20140320
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "stdlib.h"
 0004           ; #include "spi_sram.h"
 0004           ; #include "string.h"           // used for any of the string fcns supported by API
 0004           ; #include "stdio.h"            // this is used for fcns....
 0004           ; #include "ctype.h"            // this is used for fcns.. csspanf() and cstork()
 0004           ; 
 0004           ; // GPIO Defines
 0004           ; #define TRIGGER_HIGH  {TRIGGER_Data_ADDR |=  TRIGGER_MASK;}
 0004           ; #define TRIGGER_LOW           {TRIGGER_Data_ADDR &= ~TRIGGER_MASK;}
 0004           ; 
 0004           ; // Define Sampling Rates
 0004           ; #define SAMPLING_RATE_1250 149 // (150-1)
 0004           ; #define SAMPLING_RATE_1500 124 // (125-1)
 0004           ; #define SAMPLING_RATE_1875  99 // (100-1)
 0004           ; #define SAMPLING_RATE_2500  74 //  (75-1)
 0004           ; #define SAMPLING_RATE_3125  59 //  (60-1)
 0004           ; #define SAMPLING_RATE_3750  49 //  (50-1)
 0004           ; #define SAMPLING_RATE_6250  29 //  (30-1)
 0004           ; #define SAMPLING_RATE_7500  24 //  (25-1)
 0004           ; #define SAMPLING_RATE_9375  19 //  (20-1)
 0004           ; 
 0004           ; // DACUpdate Period = 4*DelSig_DecimationRate = 128 for DS232
 0004           ; #define DACUPDATE_PERIOD   127 // (128 - 1)
 0004           ; 
 0004           ; // Globals
 0004           ; BYTE DACUpdateDone = 0;       // Flag which ISR sets when its time to update the DACs with output
 0004           ; char buf[80];                 // Buffer which the UART command line will be stored            
 0004           ; char chAMemBlk = -1;  // Memory block that channel B will use (-1 for none)
 0004           ; char chBMemBlk = -1;  // Memory block that channel B will use (-1 for none)
 0004           ; int triggerAddress = 0; // Address at which the trigger will be triggered
 0004           ; 
 0004           ; // This function gets a line of text. It writes data into buffer with a maximum size of bufferLen. The function returns number of bytes written
 0004           ; // when enter is pressed
 0004           ; void GetLine(char *buffer, char bufferLen)
 0004           ; {
 0004                   .dbline 109
 0004           ;       static char rubout[4] = { 0x08, 0x20, 0x08, 0x00 }; // Rubout Sequence consists of Backspace Space Backspace. This is the null-terminated string
 0004           ;       
 0004           ;       char c;
 0004           ;       char strPos = 0; // Current position in the string
 0004 560100            mov [X+1],0
 0007                   .dbline 111
 0007           ;       
 0007           ;       UART_PutChar('>'); // Print line pointer
 0007 10                push X
 0008 503E              mov A,62
 000A 7C0000            xcall _UART_PutChar
 000D 20                pop X
 000E 808F              xjmp L4
 0010           L3:
 0010                   .dbline 114
 0010           ;       
 0010           ;       while (1)
 0010           ;       {
 0010                   .dbline 115
 0010           ;               c = UART_cReadChar(); // Use UART module to read the character user enters
 0010 10                push X
 0011 7C0000            xcall _UART_cReadChar
 0014 20                pop X
 0015 62D000            mov REG[0xd0],>__r0
 0018 5400              mov [X+0],A
 001A                   .dbline 117
 001A           ;               
 001A           ;               if (c == 0x08 || c == 0x7F) // Delete or backspace pressed
 001A 3D0008            cmp [X+0],8
 001D A006              jz L8
 001F 3D007F            cmp [X+0],127
 0022 B017              jnz L6
 0024           L8:
 0024                   .dbline 119
 0024           ;               {
 0024           ;                       if (strPos > 0) // Only delete if there are characters to delete
 0024                   .dbline 119
 0024 5000              mov A,0
 0026 3B01              cmp A,[X+1]
 0028 D075              jnc L7
 002A           X1:
 002A                   .dbline 121
 002A           ;                       {
 002A           ;                               strPos--; // Set the position back one
 002A                   .dbline 121
 002A 7B01              dec [X+1]
 002C                   .dbline 122
 002C           ;                               UART_PutString(rubout); // Sends the rubout sequence to the serial.
 002C 10                push X
 002D 5000              mov A,>L2
 002F 08                push A
 0030 5000              mov A,<L2
 0032 5C                mov X,A
 0033 18                pop A
 0034 7C0000            xcall _UART_PutString
 0037 20                pop X
 0038                   .dbline 123
 0038           ;                       }
 0038                   .dbline 124
 0038           ;               }
 0038 8065              xjmp L7
 003A           L6:
 003A                   .dbline 125
 003A           ;               else if (c == 0x0D) // Newline enter is pressed
 003A 3D000D            cmp [X+0],13
 003D B022              jnz L11
 003F                   .dbline 127
 003F           ;               {
 003F           ;                       buffer[strPos] = 0x00; // put the null character at the current strPos
 003F                   .dbline 127
 003F 62D000            mov REG[0xd0],>__r0
 0042 5201              mov A,[X+1]
 0044 5300              mov [__r1],A
 0046 550000            mov [__r0],0
 0049 52FC              mov A,[X-4]
 004B 0400              add [__r1],A
 004D 52FB              mov A,[X-5]
 004F 0C00              adc [__r0],A
 0051 5100              mov A,[__r0]
 0053 60D5              mov REG[0xd5],A
 0055 5000              mov A,0
 0057 3F00              mvi [__r1],A
 0059                   .dbline 128
 0059           ;                       UART_PutCRLF(); // Go to another line
 0059 10                push X
 005A 7C0000            xcall _UART_PutCRLF
 005D 20                pop X
 005E                   .dbline 129
 005E           ;                       break;
 005E 8041              xjmp L1
 0060           L11:
 0060                   .dbline 131
 0060           ;               }
 0060           ;               else if (c >= 0x20 && c < 0x7F) // only valid characters to the string. These are any alphabet, numeric, or symbols
 0060 3D0020            cmp [X+0],32
 0063 C03A              jc L13
 0065           X2:
 0065 3D007F            cmp [X+0],127
 0068 D035              jnc L13
 006A           X3:
 006A                   .dbline 133
 006A           ;               {
 006A           ;                       if (strPos < bufferLen) // If there is space in the buffer
 006A                   .dbline 133
 006A 5201              mov A,[X+1]
 006C 3BFA              cmp A,[X-6]
 006E D028              jnc L15
 0070           X4:
 0070                   .dbline 135
 0070           ;                       {
 0070           ;                               buffer[strPos++] = c; // Set the current character in buffer to c and then increment strPos
 0070                   .dbline 135
 0070 62D000            mov REG[0xd0],>__r0
 0073 5201              mov A,[X+1]
 0075 5300              mov [__r1],A
 0077 550000            mov [__r0],0
 007A 0101              add A,1
 007C 5401              mov [X+1],A
 007E 52FC              mov A,[X-4]
 0080 0400              add [__r1],A
 0082 52FB              mov A,[X-5]
 0084 0C00              adc [__r0],A
 0086 5100              mov A,[__r0]
 0088 60D5              mov REG[0xd5],A
 008A 5200              mov A,[X+0]
 008C 3F00              mvi [__r1],A
 008E                   .dbline 136
 008E           ;                               UART_PutChar(c); // Send the character to the computer
 008E 10                push X
 008F 5200              mov A,[X+0]
 0091 7C0000            xcall _UART_PutChar
 0094 20                pop X
 0095                   .dbline 137
 0095           ;                       }
 0095 8008              xjmp L16
 0097           L15:
 0097                   .dbline 139
 0097           ;                       else
 0097           ;                               UART_PutChar(0x07); // Send BEL key because there is no more space left to add to the string
 0097 10                push X
 0098 5007              mov A,7
 009A 7C0000            xcall _UART_PutChar
 009D 20                pop X
 009E           L16:
 009E                   .dbline 140
 009E           ;               }
 009E           L13:
 009E           L7:
 009E                   .dbline 141
 009E           ;       }
 009E           L4:
 009E                   .dbline 113
 009E 8F71              xjmp L3
 00A0           X0:
 00A0                   .dbline -2
 00A0           L1:
 00A0 38FE              add SP,-2
 00A2 20                pop X
 00A3                   .dbline 0 ; func end
 00A3 7F                ret
 00A4                   .dbsym l strPos 1 c
 00A4                   .dbsym l c 0 c
 00A4                   .dbsym l bufferLen -6 c
 00A4                   .dbsym l buffer -5 pc
 00A4                   .dbend
 00A4                   .dbfunc e Lowercase _Lowercase fpc
 00A4           ;              i -> X+0
 00A4           ;            str -> X-5
 00A4           _Lowercase::
 00A4                   .dbline -1
 00A4 10                push X
 00A5 4F                mov X,SP
 00A6 3804              add SP,4
 00A8                   .dbline 148
 00A8           ;       
 00A8           ;       return;
 00A8           ; }
 00A8           ; 
 00A8           ; // Takes input argument str and converts each character into a lowercase character. Returns that str. Note: This function alters str
 00A8           ; char *Lowercase(char *str)
 00A8           ; {
 00A8                   .dbline 150
 00A8           ;       int i;
 00A8           ;       for (i = 0; str[i] != '\0'; ++i) // Loop through each character in str and call tolower on it
 00A8 560100            mov [X+1],0
 00AB 560000            mov [X+0],0
 00AE 8043              xjmp L21
 00B0           L18:
 00B0                   .dbline 151
 00B0           ;               str[i] = tolower(str[i]); // Set the character to be the lowercase of the character
 00B0 62D000            mov REG[0xd0],>__r0
 00B3 5201              mov A,[X+1]
 00B5 03FC              add A,[X-4]
 00B7 5300              mov [__r1],A
 00B9 5200              mov A,[X+0]
 00BB 0BFB              adc A,[X-5]
 00BD 5300              mov [__r0],A
 00BF 5100              mov A,[__r1]
 00C1 5403              mov [X+3],A
 00C3 5100              mov A,[__r0]
 00C5 5402              mov [X+2],A
 00C7 60D4              mov REG[0xd4],A
 00C9 3E00              mvi A,[__r1]
 00CB 7A00              dec [__r1]
 00CD 5300              mov [__r3],A
 00CF 5000              mov A,0
 00D1 08                push A
 00D2 5100              mov A,[__r3]
 00D4 08                push A
 00D5 7C0000            xcall _tolower
 00D8 38FE              add SP,-2
 00DA 62D000            mov REG[0xd0],>__r0
 00DD 5100              mov A,[__r1]
 00DF 5300              mov [__r0],A
 00E1 5203              mov A,[X+3]
 00E3 5300              mov [__r3],A
 00E5 5202              mov A,[X+2]
 00E7 60D5              mov REG[0xd5],A
 00E9 5100              mov A,[__r0]
 00EB 3F00              mvi [__r3],A
 00ED           L19:
 00ED                   .dbline 150
 00ED 7701              inc [X+1]
 00EF 0F0000            adc [X+0],0
 00F2           L21:
 00F2                   .dbline 150
 00F2 62D000            mov REG[0xd0],>__r0
 00F5 5201              mov A,[X+1]
 00F7 03FC              add A,[X-4]
 00F9 5300              mov [__r1],A
 00FB 5200              mov A,[X+0]
 00FD 0BFB              adc A,[X-5]
 00FF 60D4              mov REG[0xd4],A
 0101 3E00              mvi A,[__r1]
 0103 3900              cmp A,0
 0105 BFAA              jnz L18
 0107                   .dbline 153
 0107           ;       
 0107           ;       return str; // Return the string
 0107 52FC              mov A,[X-4]
 0109 5300              mov [__r1],A
 010B 52FB              mov A,[X-5]
 010D 5300              mov [__r0],A
 010F                   .dbline -2
 010F           L17:
 010F 38FC              add SP,-4
 0111 20                pop X
 0112                   .dbline 0 ; func end
 0112 7F                ret
 0113                   .dbsym l i 0 I
 0113                   .dbsym l str -5 pc
 0113                   .dbend
 0113                   .dbfunc e PlaySamples _PlaySamples fV
 0113           ;       endAddrB -> X+10
 0113           ;       endAddrA -> X+8
 0113           ;     startAddrB -> X+6
 0113           ;     startAddrA -> X+4
 0113           ;          addrB -> X+2
 0113           ;          addrA -> X+0
 0113           _PlaySamples::
 0113                   .dbline -1
 0113 10                push X
 0114 4F                mov X,SP
 0115 380C              add SP,12
 0117                   .dbline 158
 0117           ; }
 0117           ; 
 0117           ; // This function plays channel A and B with the data at memory blocks chAMemBlk and chBMemBlk, respectively
 0117           ; void PlaySamples(void)
 0117           ; {     
 0117                   .dbline 159
 0117           ;       WORD startAddrA = chAMemBlk * 0x2000; // Where the address starts for channel A
 0117 62D000            mov REG[0xd0],>_chAMemBlk
 011A 5100              mov A,[_chAMemBlk]
 011C 62D000            mov REG[0xd0],>__r0
 011F 5300              mov [__r0],A
 0121 550000            mov [__r1],0
 0124 6500              asl [__r0]
 0126 6500              asl [__r1]
 0128 6B00              rlc [__r0]
 012A 6500              asl [__r1]
 012C 6B00              rlc [__r0]
 012E 6500              asl [__r1]
 0130 6B00              rlc [__r0]
 0132 6500              asl [__r1]
 0134 6B00              rlc [__r0]
 0136 5100              mov A,[__r1]
 0138 5405              mov [X+5],A
 013A 5100              mov A,[__r0]
 013C 5404              mov [X+4],A
 013E                   .dbline 160
 013E           ;       WORD endAddrA = startAddrA + 0x2000; // Where the address ends for channel A
 013E 5205              mov A,[X+5]
 0140 0100              add A,0
 0142 5409              mov [X+9],A
 0144 5204              mov A,[X+4]
 0146 0920              adc A,32
 0148 5408              mov [X+8],A
 014A                   .dbline 161
 014A           ;       WORD addrA = startAddrA; // Current address position for channel B
 014A 5205              mov A,[X+5]
 014C 5401              mov [X+1],A
 014E 5204              mov A,[X+4]
 0150 5400              mov [X+0],A
 0152                   .dbline 163
 0152           ;       
 0152           ;       WORD startAddrB = chBMemBlk * 0x2000; // Where the address starts for channel B
 0152 62D000            mov REG[0xd0],>_chBMemBlk
 0155 5100              mov A,[_chBMemBlk]
 0157 62D000            mov REG[0xd0],>__r0
 015A 5300              mov [__r0],A
 015C 550000            mov [__r1],0
 015F 6500              asl [__r0]
 0161 6500              asl [__r1]
 0163 6B00              rlc [__r0]
 0165 6500              asl [__r1]
 0167 6B00              rlc [__r0]
 0169 6500              asl [__r1]
 016B 6B00              rlc [__r0]
 016D 6500              asl [__r1]
 016F 6B00              rlc [__r0]
 0171 5100              mov A,[__r1]
 0173 5407              mov [X+7],A
 0175 5100              mov A,[__r0]
 0177 5406              mov [X+6],A
 0179                   .dbline 164
 0179           ;       WORD endAddrB = startAddrB + 0x2000; // Where the address ends for channel B
 0179 5207              mov A,[X+7]
 017B 0100              add A,0
 017D 540B              mov [X+11],A
 017F 5206              mov A,[X+6]
 0181 0920              adc A,32
 0183 540A              mov [X+10],A
 0185                   .dbline 165
 0185           ;       WORD addrB = startAddrB; // Current address position for channel B
 0185 5207              mov A,[X+7]
 0187 5403              mov [X+3],A
 0189 5206              mov A,[X+6]
 018B 5402              mov [X+2],A
 018D                   .dbline 167
 018D           ;       
 018D           ;       SPIRAM_WriteStatusRegister(SPIRAM_BYTE_MODE | SPIRAM_DISABLE_HOLD); // Set SPIRAM to byte mode b/c we read one byte at a time
 018D 5001              mov A,1
 018F 08                push A
 0190 7C0000            xcall _SPIRAM_WriteStatusRegister
 0193 38FF              add SP,-1
 0195 62D000            mov REG[0xd0],>__r0
 0198                   .dbline 168
 0198           ;       DACUpdate_Start(); // Start the DACUpdate timer
 0198 10                push X
 0199 7C0000            xcall _DACUpdate_Start
 019C                   .dbline 169
 019C           ;       UART_CPutString("Press any key to abort\r\n");
 019C 5040              mov A,>L23
 019E 08                push A
 019F 5040              mov A,<L23
 01A1 5C                mov X,A
 01A2 18                pop A
 01A3 7C0000            xcall _UART_CPutString
 01A6 20                pop X
 01A7 8097              xjmp L25
 01A9           L24:
 01A9                   .dbline 171
 01A9           ;       while (!UART_cReadChar())
 01A9           ;       {
 01A9                   .dbline 175
 01A9           ;               //TRIGGER_Data_ADDR |= TRIGGER_MASK;    // take trigger high then low
 01A9           ;               //TRIGGER_Data_ADDR &=  ~TRIGGER_MASK;
 01A9           ;               
 01A9           ;               if (DACUpdateDone) // Time to update the DACs
 01A9 62D000            mov REG[0xd0],>_DACUpdateDone
 01AC 3C0000            cmp [_DACUpdateDone],0
 01AF A08F              jz L27
 01B1                   .dbline 177
 01B1           ;               {
 01B1           ;                       if (chAMemBlk != -1) // If there is a valid memory block to output
 01B1                   .dbline 177
 01B1 62D000            mov REG[0xd0],>_chAMemBlk
 01B4 3C00FF            cmp [_chAMemBlk],-1
 01B7 A03D              jz L29
 01B9                   .dbline 179
 01B9           ;                       {
 01B9           ;                               DAC8A_WriteStall(SPIRAM_ReadByte(addrA));
 01B9                   .dbline 179
 01B9 5200              mov A,[X+0]
 01BB 08                push A
 01BC 5201              mov A,[X+1]
 01BE 08                push A
 01BF 7C0000            xcall _SPIRAM_ReadByte
 01C2 38FE              add SP,-2
 01C4 62D000            mov REG[0xd0],>__r0
 01C7 10                push X
 01C8 7C0000            xcall _DAC8A_WriteStall
 01CB 20                pop X
 01CC                   .dbline 180
 01CC           ;                               if (++addrA > endAddrA) addrA = startAddrA;
 01CC 62D000            mov REG[0xd0],>__r0
 01CF 5201              mov A,[X+1]
 01D1 0101              add A,1
 01D3 5300              mov [__r1],A
 01D5 5200              mov A,[X+0]
 01D7 0900              adc A,0
 01D9 5300              mov [__r0],A
 01DB 5100              mov A,[__r1]
 01DD 5401              mov [X+1],A
 01DF 5100              mov A,[__r0]
 01E1 5400              mov [X+0],A
 01E3 5209              mov A,[X+9]
 01E5 1200              sub A,[__r1]
 01E7 5208              mov A,[X+8]
 01E9 1A00              sbb A,[__r0]
 01EB D009              jnc L31
 01ED           X5:
 01ED                   .dbline 180
 01ED 5205              mov A,[X+5]
 01EF 5401              mov [X+1],A
 01F1 5204              mov A,[X+4]
 01F3 5400              mov [X+0],A
 01F5           L31:
 01F5                   .dbline 181
 01F5           ;                       }
 01F5           L29:
 01F5                   .dbline 183
 01F5           ;                       
 01F5           ;                       if (chBMemBlk != -1) // If there is a valid memory block to output
 01F5 62D000            mov REG[0xd0],>_chBMemBlk
 01F8 3C00FF            cmp [_chBMemBlk],-1
 01FB A03D              jz L33
 01FD                   .dbline 185
 01FD           ;                       {
 01FD           ;                               DAC8B_WriteStall(SPIRAM_ReadByte(addrB));
 01FD                   .dbline 185
 01FD 5202              mov A,[X+2]
 01FF 08                push A
 0200 5203              mov A,[X+3]
 0202 08                push A
 0203 7C0000            xcall _SPIRAM_ReadByte
 0206 38FE              add SP,-2
 0208 62D000            mov REG[0xd0],>__r0
 020B 10                push X
 020C 7C0000            xcall _DAC8B_WriteStall
 020F 20                pop X
 0210                   .dbline 186
 0210           ;                               if (++addrB > endAddrB) addrB = startAddrB;
 0210 62D000            mov REG[0xd0],>__r0
 0213 5203              mov A,[X+3]
 0215 0101              add A,1
 0217 5300              mov [__r1],A
 0219 5202              mov A,[X+2]
 021B 0900              adc A,0
 021D 5300              mov [__r0],A
 021F 5100              mov A,[__r1]
 0221 5403              mov [X+3],A
 0223 5100              mov A,[__r0]
 0225 5402              mov [X+2],A
 0227 520B              mov A,[X+11]
 0229 1200              sub A,[__r1]
 022B 520A              mov A,[X+10]
 022D 1A00              sbb A,[__r0]
 022F D009              jnc L35
 0231           X6:
 0231                   .dbline 186
 0231 5207              mov A,[X+7]
 0233 5403              mov [X+3],A
 0235 5206              mov A,[X+6]
 0237 5402              mov [X+2],A
 0239           L35:
 0239                   .dbline 187
 0239           ;                       }
 0239           L33:
 0239                   .dbline 189
 0239           ;                       
 0239           ;                       DACUpdateDone = 0; // Reset flag
 0239 62D000            mov REG[0xd0],>_DACUpdateDone
 023C 550000            mov [_DACUpdateDone],0
 023F                   .dbline 190
 023F           ;               }
 023F           L27:
 023F                   .dbline 191
 023F           ;       }
 023F           L25:
 023F                   .dbline 170
 023F 10                push X
 0240 7C0000            xcall _UART_cReadChar
 0243 20                pop X
 0244 62D000            mov REG[0xd0],>__r0
 0247 3900              cmp A,0
 0249 AF5F              jz L24
 024B                   .dbline 192
 024B           ;       DACUpdate_Stop(); // Stop the timer because we're done playing
 024B 10                push X
 024C 7C0000            xcall _DACUpdate_Stop
 024F 20                pop X
 0250                   .dbline -2
 0250           L22:
 0250 38F4              add SP,-12
 0252 20                pop X
 0253                   .dbline 0 ; func end
 0253 7F                ret
 0254                   .dbsym l endAddrB 10 i
 0254                   .dbsym l endAddrA 8 i
 0254                   .dbsym l startAddrB 6 i
 0254                   .dbsym l startAddrA 4 i
 0254                   .dbsym l addrB 2 i
 0254                   .dbsym l addrA 0 i
 0254                   .dbend
 0254                   .dbfunc e SampleAnalog _SampleAnalog fV
 0254           ;      startAddr -> X+133
 0254           ;        endAddr -> X+131
 0254           ;           addr -> X+129
 0254           ;           temp -> X+1
 0254           ;              i -> X+0
 0254           ;       memBlock -> X-5
 0254           ;        channel -> X-4
 0254           _SampleAnalog::
 0254                   .dbline -1
 0254 10                push X
 0255 4F                mov X,SP
 0256 3889              add SP,-119
 0258                   .dbline 197
 0258           ; }
 0258           ; 
 0258           ; // Samples data from channel and puts it into memBlock. Samples 8kB worth of data at the current sampling rate
 0258           ; void SampleAnalog(char channel, char memBlock)
 0258           ; {     
 0258                   .dbline 198
 0258           ;       WORD startAddr = 0x2000 * memBlock; // Where the address starts for memBlock
 0258 62D000            mov REG[0xd0],>__r0
 025B 52FB              mov A,[X-5]
 025D 5300              mov [__r0],A
 025F 550000            mov [__r1],0
 0262 6500              asl [__r0]
 0264 6500              asl [__r1]
 0266 6B00              rlc [__r0]
 0268 6500              asl [__r1]
 026A 6B00              rlc [__r0]
 026C 6500              asl [__r1]
 026E 6B00              rlc [__r0]
 0270 6500              asl [__r1]
 0272 6B00              rlc [__r0]
 0274 5100              mov A,[__r1]
 0276 5486              mov [X-122],A
 0278 5100              mov A,[__r0]
 027A 5485              mov [X-123],A
 027C                   .dbline 199
 027C           ;       WORD endAddr = startAddr + 0x2000; // Where the address ends for memBlock
 027C 5286              mov A,[X-122]
 027E 0100              add A,0
 0280 5484              mov [X-124],A
 0282 5285              mov A,[X-123]
 0284 0920              adc A,32
 0286 5483              mov [X-125],A
 0288                   .dbline 204
 0288           ;       WORD addr;
 0288           ;       BYTE i;
 0288           ;       char temp[128];
 0288           ;       
 0288           ;       AMUX4_InputSelect(channel == 0 ? AMUX4_PORT0_1: AMUX4_PORT0_7); // Change sample analog source channel
 0288 3DFC00            cmp [X-4],0
 028B B009              jnz L39
 028D 568800            mov [X-120],0
 0290 568700            mov [X-121],0
 0293 8007              xjmp L40
 0295           L39:
 0295 568803            mov [X-120],3
 0298 568700            mov [X-121],0
 029B           L40:
 029B 62D000            mov REG[0xd0],>__r0
 029E 5288              mov A,[X-120]
 02A0 10                push X
 02A1 7C0000            xcall _AMUX4_InputSelect
 02A4 20                pop X
 02A5                   .dbline 205
 02A5           ;       SPIRAM_WriteStatusRegister(SPIRAM_SEQUENTIAL_MODE | SPIRAM_DISABLE_HOLD); // Set SPIRAM to sequential mode, we write bytes in packets of 128
 02A5 5041              mov A,65
 02A7 08                push A
 02A8 7C0000            xcall _SPIRAM_WriteStatusRegister
 02AB 38FF              add SP,-1
 02AD 62D000            mov REG[0xd0],>__r0
 02B0                   .dbline 206
 02B0           ;       DelSig_StartAD(); // Start the analog to digital conversion in DelSig
 02B0 10                push X
 02B1 7C0000            xcall _DelSig_StartAD
 02B4 20                pop X
 02B5                   .dbline 207
 02B5           ;       for (addr = startAddr; addr < endAddr; addr += 128) // Loop through startAddr-endAddr in 128 increments
 02B5 5286              mov A,[X-122]
 02B7 5482              mov [X-126],A
 02B9 5285              mov A,[X-123]
 02BB 5481              mov [X-127],A
 02BD 805D              xjmp L44
 02BF           L41:
 02BF                   .dbline 208
 02BF           ;       {
 02BF                   .dbline 209
 02BF           ;               for (i = 0; i < 128; i++) // Read 128 bytes from the DelSig
 02BF 560000            mov [X+0],0
 02C2 8031              xjmp L48
 02C4           L49:
 02C4                   .dbline 211
 02C4           ;               {
 02C4           ;                       while (!DelSig_fIsDataAvailable());
 02C4           L50:
 02C4                   .dbline 211
 02C4 10                push X
 02C5 7C0000            xcall _DelSig_fIsDataAvailable
 02C8 20                pop X
 02C9 62D000            mov REG[0xd0],>__r0
 02CC 3900              cmp A,0
 02CE AFF5              jz L49
 02D0                   .dbline 212
 02D0           ;                       temp[i] = DelSig_cGetDataClearFlag();
 02D0 10                push X
 02D1 7C0000            xcall _DelSig_cGetDataClearFlag
 02D4 20                pop X
 02D5 62D000            mov REG[0xd0],>__r0
 02D8 5300              mov [__r0],A
 02DA 550007            mov [__r2],7
 02DD 5A00              mov [__r3],X
 02DF 060001            add [__r3],1
 02E2 5200              mov A,[X+0]
 02E4 0200              add A,[__r3]
 02E6 5300              mov [__r3],A
 02E8 5000              mov A,0
 02EA 0A00              adc A,[__r2]
 02EC 60D5              mov REG[0xd5],A
 02EE 5100              mov A,[__r0]
 02F0 3F00              mvi [__r3],A
 02F2                   .dbline 213
 02F2           ;               }
 02F2           L46:
 02F2                   .dbline 209
 02F2 7700              inc [X+0]
 02F4           L48:
 02F4                   .dbline 209
 02F4 3D0080            cmp [X+0],-128
 02F7 CFCC              jc L50
 02F9           X7:
 02F9                   .dbline 215
 02F9           ;               
 02F9           ;               SPIRAM_WriteArray(addr, temp, 128); // Write those bytes to SPIRAm
 02F9 5080              mov A,-128
 02FB 08                push A
 02FC 62D000            mov REG[0xd0],>__r0
 02FF 5A00              mov [__r1],X
 0301 060001            add [__r1],1
 0304 5007              mov A,7
 0306 08                push A
 0307 5100              mov A,[__r1]
 0309 08                push A
 030A 5281              mov A,[X-127]
 030C 08                push A
 030D 5282              mov A,[X-126]
 030F 08                push A
 0310 7C0000            xcall _SPIRAM_WriteArray
 0313 38FB              add SP,-5
 0315                   .dbline 216
 0315           ;       }       
 0315           L42:
 0315                   .dbline 207
 0315 078280            add [X-126],-128
 0318 0F8100            adc [X-127],0
 031B           L44:
 031B                   .dbline 207
 031B 5282              mov A,[X-126]
 031D 1384              sub A,[X-124]
 031F 5281              mov A,[X-127]
 0321 1B83              sbb A,[X-125]
 0323 CF9B              jc L41
 0325           X8:
 0325                   .dbline 217
 0325           ;       DelSig_StopAD(); // Stop the conversions once were done sampling
 0325 10                push X
 0326 7C0000            xcall _DelSig_StopAD
 0329 20                pop X
 032A                   .dbline -2
 032A           L37:
 032A 3877              add SP,-137
 032C 20                pop X
 032D                   .dbline 0 ; func end
 032D 7F                ret
 032E                   .dbsym l startAddr 133 i
 032E                   .dbsym l endAddr 131 i
 032E                   .dbsym l addr 129 i
 032E                   .dbsym l temp 1 A[128:128]c
 032E                   .dbsym l i 0 c
 032E                   .dbsym l memBlock -5 c
 032E                   .dbsym l channel -4 c
 032E                   .dbend
 032E                   .dbfunc e main _main fV
 032E           ;        address -> X+4
 032E           ;           ksps -> X+6
 032E           ;   samplingRate -> X+4
 032E           ;       memBlock -> X+5
 032E           ;        channel -> X+4
 032E           ;       memBlock -> X+5
 032E           ;        channel -> X+4
 032E           ;            cmd -> X+2
 032E           ;         params -> X+0
 032E           _main::
 032E                   .dbline -1
 032E 10                push X
 032F 4F                mov X,SP
 0330 3809              add SP,9
 0332                   .dbline 221
 0332           ; }
 0332           ; 
 0332           ; void main(void)
 0332           ; {
 0332                   .dbline 223
 0332           ;       // Make sure nCS is high before doing anything
 0332           ;       nCS_HIGH;
 0332                   .dbline 223
 0332 430404            or REG[0x4],4
 0335                   .dbline 223
 0335                   .dbline 223
 0335                   .dbline 230
 0335           ; 
 0335           ;       // Make the oscilloscope external trigger signal low. Trigger must be quickly
 0335           ;       // brough high-then-low when you want the oscilloscope to draw the signals
 0335           ;       // on DACA and DACB. Trigger (P1[1]) must be connected to the EXT TRIG input
 0335           ;       // on the back of the oscilloscope and the Trigger Source must be set to
 0335           ;       // External. The oscilloscope should also be set for Normal Mode Triggering.
 0335           ;       TRIGGER_LOW;
 0335                   .dbline 230
 0335 4104FD            and REG[0x4],-3
 0338                   .dbline 230
 0338                   .dbline 230
 0338                   .dbline 233
 0338           ; 
 0338           ;       // Enable global interrutps
 0338           ;       M8C_EnableGInt;
 0338 7101                      or  F, 01h
 033A           
 033A                   .dbline 236
 033A           ; 
 033A           ;       // Start the UART
 033A           ;       UART_Start(UART_PARITY_NONE);
 033A 10                push X
 033B 5000              mov A,0
 033D 7C0000            xcall _UART_Start
 0340                   .dbline 237
 0340           ;       UART_PutCRLF();
 0340 7C0000            xcall _UART_PutCRLF
 0343                   .dbline 240
 0343           ; 
 0343           ;       // Start the SPIM Module
 0343           ;       SPIM_Start(SPIM_SPIM_MODE_0 | SPIM_SPIM_MSB_FIRST);
 0343 5000              mov A,0
 0345 7C0000            xcall _SPIM_Start
 0348                   .dbline 243
 0348           ; 
 0348           ;       // Start the DelSig custom clock source at the default sampling rate
 0348           ;       DelSigClock_WritePeriod(SAMPLING_RATE_1250);
 0348 5095              mov A,-107
 034A 7C0000            xcall _DelSigClock_WritePeriod
 034D                   .dbline 244
 034D           ;       DelSigClock_WriteCompareValue(SAMPLING_RATE_1250>>1);
 034D 504A              mov A,74
 034F 7C0000            xcall _DelSigClock_WriteCompareValue
 0352                   .dbline 245
 0352           ;       DelSigClock_Start();
 0352 7C0000            xcall _DelSigClock_Start
 0355                   .dbline 248
 0355           ; 
 0355           ;       // Start the analog mux and select P0[1] (Channel A) as default
 0355           ;       AMUX4_Start();
 0355 7C0000            xcall _AMUX4_Start
 0358                   .dbline 249
 0358           ;       AMUX4_InputSelect(AMUX4_PORT0_1);
 0358 5000              mov A,0
 035A 7C0000            xcall _AMUX4_InputSelect
 035D                   .dbline 252
 035D           ; 
 035D           ;       // Start the PGA
 035D           ;       PGA_Start(PGA_HIGHPOWER);
 035D 5003              mov A,3
 035F 7C0000            xcall _PGA_Start
 0362                   .dbline 257
 0362           ; 
 0362           ;       // Start the DelSig but do not start taking samples yet.
 0362           ;       // Note: The DelSig PWM block output can be monitored on P1[0]. This
 0362           ;       // can be used to verify the sampling rate.
 0362           ;       DelSig_Start(DelSig_HIGHPOWER);
 0362 5003              mov A,3
 0364 7C0000            xcall _DelSig_Start
 0367                   .dbline 265
 0367           ; 
 0367           ;       // Enable interrupts on the counter that sets the DAC output rate.
 0367           ;       // Start the module only when actually outputting samples and
 0367           ;       // stop it when done. Don't forget to write the period after stoping
 0367           ;       // to reset the count register.
 0367           ;       // NOTE: You can watch this counter on P1[7] to compare desired
 0367           ;       // output rate with your actual output rate.
 0367           ;       DACUpdate_WritePeriod(DACUPDATE_PERIOD);
 0367 507F              mov A,127
 0369 7C0000            xcall _DACUpdate_WritePeriod
 036C                   .dbline 266
 036C           ;       DACUpdate_EnableInt();
 036C 7C0000            xcall _DACUpdate_EnableInt
 036F                   .dbline 269
 036F           ; 
 036F           ;       // Start the DACs
 036F           ;       DAC8A_Start(DAC8A_HIGHPOWER);
 036F 5003              mov A,3
 0371 7C0000            xcall _DAC8A_Start
 0374                   .dbline 270
 0374           ;       DAC8B_Start(DAC8B_HIGHPOWER);
 0374 5003              mov A,3
 0376 7C0000            xcall _DAC8B_Start
 0379                   .dbline 273
 0379           ;       
 0379           ;               // This is the command usage string
 0379           ;       UART_CPutString("########################## Lab 11 Data Acquisition System ########################\r\n\
 0379 5033              mov A,>L53
 037B 08                push A
 037C 5033              mov A,<L53
 037E 5C                mov X,A
 037F 18                pop A
 0380 7C0000            xcall _UART_CPutString
 0383 20                pop X
 0384 8642              xjmp L55
 0386           L54:
 0386                   .dbline 307
 0386           ; # input X A \r\n\
 0386           ; #\r\n\
 0386           ; #     Samples input channel to memory block\r\n\
 0386           ; #             X - Either A/B to signify channel being altered\r\n\
 0386           ; #             A - Memory block(0-3) being routed\r\n\
 0386           ; #\r\n\
 0386           ; # output X A\r\n\
 0386           ; #     Routes output channel to read from memory block \r\n\
 0386           ; #             X - Either A/B to signify channel being altered\r\n\
 0386           ; #             A - Memory block(0-3 or -1 for none) being routed\r\n\
 0386           ; #\r\n\
 0386           ; # rate X\r\n\
 0386           ; #     Selects a rate to sample the channels when reading and writing\r\n\
 0386           ; #             X - One of the values below\r\n\
 0386           ; #                     1. 1.25  ksps \r\n\
 0386           ; #                     2. 1.5   ksps\r\n\
 0386           ; #                     3. 1.87  ksps\r\n\
 0386           ; #                     4. 2.5   ksps\r\n\
 0386           ; #                     5. 3.125 ksps\r\n\
 0386           ; #                     6. 3.75  ksps\r\n\
 0386           ; #                     7. 6.25  ksps\r\n\
 0386           ; #                     8. 7.5   ksps\r\n\
 0386           ; #                     9. 9.37  ksps\r\n\
 0386           ; #\r\n\
 0386           ; # trigger XXX H\r\n\
 0386           ; #     Sets the relative address to trigger\r\n\
 0386           ; #             XXX - Either hex/dec for the address\r\n\
 0386           ; #             H - values in hexadecimal or decimal.  Range is 0-8192 for dec or 0-2000 for hex\r\n\
 0386           ; #\r\n\
 0386           ; # start\r\n\
 0386           ; #     Starts the output channels. They will continue to play until looped over\r\n\
 0386           ; #####################################################################\r\n");
 0386           ;       while (1)
 0386           ;       {
 0386                   .dbline 311
 0386           ;               char *cmd;
 0386           ;               char *params;
 0386           ;               
 0386           ;               GetLine(buf, 79); // Retrieves a line with a maximum length of 79 characters and put it in buf.
 0386 504F              mov A,79
 0388 08                push A
 0389 5000              mov A,>_buf
 038B 08                push A
 038C 5000              mov A,<_buf
 038E 08                push A
 038F 9C6F              xcall _GetLine
 0391                   .dbline 313
 0391           ;               
 0391           ;               cmd = Lowercase(cstrtok(buf, " ")); // Get the first word from the entered string and lowercase it.
 0391 5031              mov A,>L57
 0393 08                push A
 0394 5031              mov A,<L57
 0396 08                push A
 0397 5000              mov A,>_buf
 0399 08                push A
 039A 5000              mov A,<_buf
 039C 08                push A
 039D 7C0000            xcall _cstrtok
 03A0 38F9              add SP,-7
 03A2 62D000            mov REG[0xd0],>__r0
 03A5 5100              mov A,[__r0]
 03A7 08                push A
 03A8 5100              mov A,[__r1]
 03AA 08                push A
 03AB 9CF7              xcall _Lowercase
 03AD 62D000            mov REG[0xd0],>__r0
 03B0 5100              mov A,[__r1]
 03B2 5403              mov [X+3],A
 03B4 5100              mov A,[__r0]
 03B6 5402              mov [X+2],A
 03B8                   .dbline 314
 03B8           ;               if (!cstrcmp("input", cmd)) // If the command input was entered
 03B8 5202              mov A,[X+2]
 03BA 08                push A
 03BB 5203              mov A,[X+3]
 03BD 08                push A
 03BE 502B              mov A,>L60
 03C0 08                push A
 03C1 502B              mov A,<L60
 03C3 08                push A
 03C4 7C0000            xcall _cstrcmpLMM
 03C7 38FA              add SP,-6
 03C9 62D000            mov REG[0xd0],>__r0
 03CC 3C0000            cmp [__r0],0
 03CF B149              jnz L58
 03D1 3C0000            cmp [__r1],0
 03D4 B144              jnz L58
 03D6           X10:
 03D6                   .dbline 316
 03D6           ;               {
 03D6           ;                       char channel;
 03D6                   .dbline 319
 03D6           ;                       int memBlock;
 03D6           ; 
 03D6           ;                       params = cstrtok(0x00, " "); // 0x00 indicates it will continue from last cstrtok command and get next word. This gets the next parameter
 03D6 5031              mov A,>L57
 03D8 08                push A
 03D9 5031              mov A,<L57
 03DB 08                push A
 03DC 5000              mov A,0
 03DE 08                push A
 03DF 08                push A
 03E0 7C0000            xcall _cstrtok
 03E3 62D000            mov REG[0xd0],>__r0
 03E6 5100              mov A,[__r1]
 03E8 5401              mov [X+1],A
 03EA 5100              mov A,[__r0]
 03EC 5400              mov [X+0],A
 03EE                   .dbline 325
 03EE           ; 
 03EE           ;                       // csscanf if used to parse the string into values such as hexadecimal or integers
 03EE           ;                       // It returns the number of parameters it parsed which should be one
 03EE           ;                       // If the length of the params is not right or it does not parse the right amount, it returns an error
 03EE           ;                       // %c gets a character, the channel
 03EE           ;                       if (strlen(params) != 1 || csscanf(params, "%c", &channel) != 1) goto error;
 03EE 5200              mov A,[X+0]
 03F0 08                push A
 03F1 5201              mov A,[X+1]
 03F3 08                push A
 03F4 7C0000            xcall _strlenLMM
 03F7 38FA              add SP,-6
 03F9 62D000            mov REG[0xd0],>__r0
 03FC 3C0000            cmp [__r0],0
 03FF B032              jnz L64
 0401 3C0001            cmp [__r1],1
 0404 B02D              jnz L64
 0406           X11:
 0406 62D000            mov REG[0xd0],>__r0
 0409 5A00              mov [__r1],X
 040B 060004            add [__r1],4
 040E 5007              mov A,7
 0410 08                push A
 0411 5100              mov A,[__r1]
 0413 08                push A
 0414 5028              mov A,>L63
 0416 08                push A
 0417 5028              mov A,<L63
 0419 08                push A
 041A 5200              mov A,[X+0]
 041C 08                push A
 041D 5201              mov A,[X+1]
 041F 08                push A
 0420 7C0000            xcall _csscanf
 0423 38FA              add SP,-6
 0425 62D000            mov REG[0xd0],>__r0
 0428 3C0000            cmp [__r0],0
 042B B006              jnz X12
 042D 3C0001            cmp [__r1],1
 0430 A003              jz L61
 0432           X12:
 0432           L64:
 0432                   .dbline 325
 0432 8588              xjmp L65
 0434           L61:
 0434                   .dbline 328
 0434           ;                       
 0434           ;                       // %d gets an integer, this is the memory block at which to write
 0434           ;                       params = cstrtok(0x00, " ");
 0434 5031              mov A,>L57
 0436 08                push A
 0437 5031              mov A,<L57
 0439 08                push A
 043A 5000              mov A,0
 043C 08                push A
 043D 08                push A
 043E 7C0000            xcall _cstrtok
 0441 62D000            mov REG[0xd0],>__r0
 0444 5100              mov A,[__r1]
 0446 5401              mov [X+1],A
 0448 5100              mov A,[__r0]
 044A 5400              mov [X+0],A
 044C                   .dbline 329
 044C           ;                       if (strlen(params) != 1 || csscanf(params, "%d", &memBlock) != 1) goto error;                   
 044C 5200              mov A,[X+0]
 044E 08                push A
 044F 5201              mov A,[X+1]
 0451 08                push A
 0452 7C0000            xcall _strlenLMM
 0455 38FA              add SP,-6
 0457 62D000            mov REG[0xd0],>__r0
 045A 3C0000            cmp [__r0],0
 045D B032              jnz L69
 045F 3C0001            cmp [__r1],1
 0462 B02D              jnz L69
 0464           X13:
 0464 62D000            mov REG[0xd0],>__r0
 0467 5A00              mov [__r1],X
 0469 060005            add [__r1],5
 046C 5007              mov A,7
 046E 08                push A
 046F 5100              mov A,[__r1]
 0471 08                push A
 0472 5025              mov A,>L68
 0474 08                push A
 0475 5025              mov A,<L68
 0477 08                push A
 0478 5200              mov A,[X+0]
 047A 08                push A
 047B 5201              mov A,[X+1]
 047D 08                push A
 047E 7C0000            xcall _csscanf
 0481 38FA              add SP,-6
 0483 62D000            mov REG[0xd0],>__r0
 0486 3C0000            cmp [__r0],0
 0489 B006              jnz X14
 048B 3C0001            cmp [__r1],1
 048E A003              jz L66
 0490           X14:
 0490           L69:
 0490                   .dbline 329
 0490 852A              xjmp L65
 0492           L66:
 0492                   .dbline 332
 0492           ;                       
 0492           ;                       // If there is any data after the last arg, then the format is invalid and it should return an error
 0492           ;                       if (cstrtok(0x00, " ") != 0x00) goto error;
 0492 5031              mov A,>L57
 0494 08                push A
 0495 5031              mov A,<L57
 0497 08                push A
 0498 5000              mov A,0
 049A 08                push A
 049B 08                push A
 049C 7C0000            xcall _cstrtok
 049F 38FC              add SP,-4
 04A1 62D000            mov REG[0xd0],>__r0
 04A4 3C0000            cmp [__r0],0
 04A7 B006              jnz X15
 04A9 3C0000            cmp [__r1],0
 04AC A003              jz L70
 04AE           X15:
 04AE                   .dbline 332
 04AE 850C              xjmp L65
 04B0           L70:
 04B0                   .dbline 334
 04B0           ;                       
 04B0           ;                       channel = tolower(channel);
 04B0 62D000            mov REG[0xd0],>__r0
 04B3 5204              mov A,[X+4]
 04B5 5300              mov [__r1],A
 04B7 5000              mov A,0
 04B9 08                push A
 04BA 5100              mov A,[__r1]
 04BC 08                push A
 04BD 7C0000            xcall _tolower
 04C0 38FE              add SP,-2
 04C2 62D000            mov REG[0xd0],>__r0
 04C5 5100              mov A,[__r1]
 04C7 5404              mov [X+4],A
 04C9                   .dbline 335
 04C9           ;                       if ((channel != 'a' && channel != 'b') || memBlock < 0 || memBlock > 3)
 04C9 3D0461            cmp [X+4],97
 04CC A006              jz L75
 04CE 3D0462            cmp [X+4],98
 04D1 B020              jnz L76
 04D3           L75:
 04D3 5206              mov A,[X+6]
 04D5 1100              sub A,0
 04D7 5205              mov A,[X+5]
 04D9 3180              xor A,-128
 04DB 1980              sbb A,(0 ^ 0x80)
 04DD C014              jc L76
 04DF           X16:
 04DF 5003              mov A,3
 04E1 1306              sub A,[X+6]
 04E3 5205              mov A,[X+5]
 04E5 3180              xor A,-128
 04E7 62D000            mov REG[0xd0],>__r0
 04EA 5300              mov [__rX],A
 04EC 5080              mov A,(0 ^ 0x80)
 04EE 1A00              sbb A,[__rX]
 04F0 D003              jnc L72
 04F2           X17:
 04F2           L76:
 04F2                   .dbline 336
 04F2           ;                               goto error; // Memory block was out of range or the channel was not A or B
 04F2 84C8              xjmp L65
 04F4           L72:
 04F4                   .dbline 339
 04F4           ;                       
 04F4           ;                       // Sample given channel at memBlock
 04F4           ;                       SampleAnalog((channel == 'b'), (char)memBlock);
 04F4 62D000            mov REG[0xd0],>__r0
 04F7 5206              mov A,[X+6]
 04F9 08                push A
 04FA 3D0462            cmp [X+4],98
 04FD B009              jnz L78
 04FF 560801            mov [X+8],1
 0502 560700            mov [X+7],0
 0505 8007              xjmp L79
 0507           L78:
 0507 560800            mov [X+8],0
 050A 560700            mov [X+7],0
 050D           L79:
 050D 62D000            mov REG[0xd0],>__r0
 0510 5208              mov A,[X+8]
 0512 08                push A
 0513 9D3F              xcall _SampleAnalog
 0515 38FE              add SP,-2
 0517                   .dbline 340
 0517           ;               }
 0517 84AF              xjmp L55
 0519           L58:
 0519                   .dbline 341
 0519           ;               else if (!cstrcmp("output", cmd)) // If the command output was entered
 0519 5202              mov A,[X+2]
 051B 08                push A
 051C 5203              mov A,[X+3]
 051E 08                push A
 051F 501E              mov A,>L82
 0521 08                push A
 0522 501E              mov A,<L82
 0524 08                push A
 0525 7C0000            xcall _cstrcmpLMM
 0528 38FC              add SP,-4
 052A 62D000            mov REG[0xd0],>__r0
 052D 3C0000            cmp [__r0],0
 0530 B13B              jnz L80
 0532 3C0000            cmp [__r1],0
 0535 B136              jnz L80
 0537           X18:
 0537                   .dbline 343
 0537           ;               {
 0537           ;                       char channel;
 0537                   .dbline 346
 0537           ;                       int memBlock;
 0537           ; 
 0537           ;                       params = cstrtok(0x00, " "); // 0x00 indicates it will continue from last cstrtok command and get next word. This gets the next parameter
 0537 5031              mov A,>L57
 0539 08                push A
 053A 5031              mov A,<L57
 053C 08                push A
 053D 5000              mov A,0
 053F 08                push A
 0540 08                push A
 0541 7C0000            xcall _cstrtok
 0544 62D000            mov REG[0xd0],>__r0
 0547 5100              mov A,[__r1]
 0549 5401              mov [X+1],A
 054B 5100              mov A,[__r0]
 054D 5400              mov [X+0],A
 054F                   .dbline 352
 054F           ; 
 054F           ;                       // csscanf if used to parse the string into values such as hexadecimal or integers
 054F           ;                       // It returns the number of parameters it parsed which should be one
 054F           ;                       // If the length of the params is not right or it does not parse the right amount, it returns an error
 054F           ;                       // %c gets a character, the channel
 054F           ;                       if (strlen(params) != 1 || csscanf(params, "%c", &channel) != 1) goto error;
 054F 5200              mov A,[X+0]
 0551 08                push A
 0552 5201              mov A,[X+1]
 0554 08                push A
 0555 7C0000            xcall _strlenLMM
 0558 38FA              add SP,-6
 055A 62D000            mov REG[0xd0],>__r0
 055D 3C0000            cmp [__r0],0
 0560 B032              jnz L85
 0562 3C0001            cmp [__r1],1
 0565 B02D              jnz L85
 0567           X19:
 0567 62D000            mov REG[0xd0],>__r0
 056A 5A00              mov [__r1],X
 056C 060004            add [__r1],4
 056F 5007              mov A,7
 0571 08                push A
 0572 5100              mov A,[__r1]
 0574 08                push A
 0575 5028              mov A,>L63
 0577 08                push A
 0578 5028              mov A,<L63
 057A 08                push A
 057B 5200              mov A,[X+0]
 057D 08                push A
 057E 5201              mov A,[X+1]
 0580 08                push A
 0581 7C0000            xcall _csscanf
 0584 38FA              add SP,-6
 0586 62D000            mov REG[0xd0],>__r0
 0589 3C0000            cmp [__r0],0
 058C B006              jnz X20
 058E 3C0001            cmp [__r1],1
 0591 A003              jz L83
 0593           X20:
 0593           L85:
 0593                   .dbline 352
 0593 8427              xjmp L65
 0595           L83:
 0595                   .dbline 355
 0595           ; 
 0595           ;                       // %d gets an integer, this is the memory block
 0595           ;                       params = cstrtok(0x00, " ");
 0595 5031              mov A,>L57
 0597 08                push A
 0598 5031              mov A,<L57
 059A 08                push A
 059B 5000              mov A,0
 059D 08                push A
 059E 08                push A
 059F 7C0000            xcall _cstrtok
 05A2 62D000            mov REG[0xd0],>__r0
 05A5 5100              mov A,[__r1]
 05A7 5401              mov [X+1],A
 05A9 5100              mov A,[__r0]
 05AB 5400              mov [X+0],A
 05AD                   .dbline 356
 05AD           ;                       if (strlen(params) != 1 || csscanf(params, "%d", &memBlock) != 1) goto error;
 05AD 5200              mov A,[X+0]
 05AF 08                push A
 05B0 5201              mov A,[X+1]
 05B2 08                push A
 05B3 7C0000            xcall _strlenLMM
 05B6 38FA              add SP,-6
 05B8 62D000            mov REG[0xd0],>__r0
 05BB 3C0000            cmp [__r0],0
 05BE B032              jnz L88
 05C0 3C0001            cmp [__r1],1
 05C3 B02D              jnz L88
 05C5           X21:
 05C5 62D000            mov REG[0xd0],>__r0
 05C8 5A00              mov [__r1],X
 05CA 060005            add [__r1],5
 05CD 5007              mov A,7
 05CF 08                push A
 05D0 5100              mov A,[__r1]
 05D2 08                push A
 05D3 5025              mov A,>L68
 05D5 08                push A
 05D6 5025              mov A,<L68
 05D8 08                push A
 05D9 5200              mov A,[X+0]
 05DB 08                push A
 05DC 5201              mov A,[X+1]
 05DE 08                push A
 05DF 7C0000            xcall _csscanf
 05E2 38FA              add SP,-6
 05E4 62D000            mov REG[0xd0],>__r0
 05E7 3C0000            cmp [__r0],0
 05EA B006              jnz X22
 05EC 3C0001            cmp [__r1],1
 05EF A003              jz L86
 05F1           X22:
 05F1           L88:
 05F1                   .dbline 356
 05F1 83C9              xjmp L65
 05F3           L86:
 05F3                   .dbline 359
 05F3           ;                       
 05F3           ;                       // If there is any data after the last arg, then the format is invalid and it should return an error
 05F3           ;                       if (cstrtok(0x00, " ") != 0x00) goto error;     
 05F3 5031              mov A,>L57
 05F5 08                push A
 05F6 5031              mov A,<L57
 05F8 08                push A
 05F9 5000              mov A,0
 05FB 08                push A
 05FC 08                push A
 05FD 7C0000            xcall _cstrtok
 0600 38FC              add SP,-4
 0602 62D000            mov REG[0xd0],>__r0
 0605 3C0000            cmp [__r0],0
 0608 B006              jnz X23
 060A 3C0000            cmp [__r1],0
 060D A003              jz L89
 060F           X23:
 060F                   .dbline 359
 060F 83AB              xjmp L65
 0611           L89:
 0611                   .dbline 361
 0611           ;                       
 0611           ;                       channel = tolower(channel);
 0611 62D000            mov REG[0xd0],>__r0
 0614 5204              mov A,[X+4]
 0616 5300              mov [__r1],A
 0618 5000              mov A,0
 061A 08                push A
 061B 5100              mov A,[__r1]
 061D 08                push A
 061E 7C0000            xcall _tolower
 0621 38FE              add SP,-2
 0623 62D000            mov REG[0xd0],>__r0
 0626 5100              mov A,[__r1]
 0628 5404              mov [X+4],A
 062A                   .dbline 362
 062A           ;                       if ((channel != 'a' && channel != 'b') || memBlock < -1 || memBlock > 3)
 062A 3D0461            cmp [X+4],97
 062D A006              jz L94
 062F 3D0462            cmp [X+4],98
 0632 B020              jnz L95
 0634           L94:
 0634 5206              mov A,[X+6]
 0636 11FF              sub A,-1
 0638 5205              mov A,[X+5]
 063A 3180              xor A,-128
 063C 197F              sbb A,(-1 ^ 0x80)
 063E C014              jc L95
 0640           X24:
 0640 5003              mov A,3
 0642 1306              sub A,[X+6]
 0644 5205              mov A,[X+5]
 0646 3180              xor A,-128
 0648 62D000            mov REG[0xd0],>__r0
 064B 5300              mov [__rX],A
 064D 5080              mov A,(0 ^ 0x80)
 064F 1A00              sbb A,[__rX]
 0651 D003              jnc L91
 0653           X25:
 0653           L95:
 0653                   .dbline 363
 0653           ;                               goto error; // Memory block was out of range or the channel was not A or B
 0653 8367              xjmp L65
 0655           L91:
 0655                   .dbline 366
 0655           ;                       
 0655           ;                       // Set specified memory block to given channel
 0655           ;                       if (channel == 'a') chAMemBlk = memBlock;
 0655 3D0461            cmp [X+4],97
 0658 B00A              jnz L96
 065A                   .dbline 366
 065A 5206              mov A,[X+6]
 065C 62D000            mov REG[0xd0],>_chAMemBlk
 065F 5300              mov [_chAMemBlk],A
 0661 8365              xjmp L55
 0663           L96:
 0663                   .dbline 367
 0663           ;                       else chBMemBlk = memBlock;
 0663 5206              mov A,[X+6]
 0665 62D000            mov REG[0xd0],>_chBMemBlk
 0668 5300              mov [_chBMemBlk],A
 066A                   .dbline 368
 066A           ;               }
 066A 835C              xjmp L55
 066C           L80:
 066C                   .dbline 369
 066C           ;               else if (!cstrcmp("rate", cmd)) // If the command rate was entered
 066C 5202              mov A,[X+2]
 066E 08                push A
 066F 5203              mov A,[X+3]
 0671 08                push A
 0672 5019              mov A,>L100
 0674 08                push A
 0675 5019              mov A,<L100
 0677 08                push A
 0678 7C0000            xcall _cstrcmpLMM
 067B 38FC              add SP,-4
 067D 62D000            mov REG[0xd0],>__r0
 0680 3C0000            cmp [__r0],0
 0683 B16F              jnz L98
 0685 3C0000            cmp [__r1],0
 0688 B16A              jnz L98
 068A           X26:
 068A                   .dbline 371
 068A           ;               {
 068A           ;                       int samplingRate;
 068A                   .dbline 373
 068A           ;                       int ksps;
 068A           ;                       params = cstrtok(0x00, " "); // 0x00 indicates it will continue from last cstrtok command and get next word. This gets the next parameter
 068A 5031              mov A,>L57
 068C 08                push A
 068D 5031              mov A,<L57
 068F 08                push A
 0690 5000              mov A,0
 0692 08                push A
 0693 08                push A
 0694 7C0000            xcall _cstrtok
 0697 62D000            mov REG[0xd0],>__r0
 069A 5100              mov A,[__r1]
 069C 5401              mov [X+1],A
 069E 5100              mov A,[__r0]
 06A0 5400              mov [X+0],A
 06A2                   .dbline 379
 06A2           ; 
 06A2           ;                       // csscanf if used to parse the string into values such as hexadecimal or integers
 06A2           ;                       // It returns the number of parameters it parsed which should be one
 06A2           ;                       // If the length of the params is not right or it does not parse the right amount, it returns an error
 06A2           ;                       // %d gets an integer, this is the memory block
 06A2           ;                       if (strlen(params) != 1 || csscanf(params, "%d", &samplingRate) != 1) goto error;
 06A2 5200              mov A,[X+0]
 06A4 08                push A
 06A5 5201              mov A,[X+1]
 06A7 08                push A
 06A8 7C0000            xcall _strlenLMM
 06AB 38FA              add SP,-6
 06AD 62D000            mov REG[0xd0],>__r0
 06B0 3C0000            cmp [__r0],0
 06B3 B032              jnz L103
 06B5 3C0001            cmp [__r1],1
 06B8 B02D              jnz L103
 06BA           X27:
 06BA 62D000            mov REG[0xd0],>__r0
 06BD 5A00              mov [__r1],X
 06BF 060004            add [__r1],4
 06C2 5007              mov A,7
 06C4 08                push A
 06C5 5100              mov A,[__r1]
 06C7 08                push A
 06C8 5025              mov A,>L68
 06CA 08                push A
 06CB 5025              mov A,<L68
 06CD 08                push A
 06CE 5200              mov A,[X+0]
 06D0 08                push A
 06D1 5201              mov A,[X+1]
 06D3 08                push A
 06D4 7C0000            xcall _csscanf
 06D7 38FA              add SP,-6
 06D9 62D000            mov REG[0xd0],>__r0
 06DC 3C0000            cmp [__r0],0
 06DF B006              jnz X28
 06E1 3C0001            cmp [__r1],1
 06E4 A003              jz L101
 06E6           X28:
 06E6           L103:
 06E6                   .dbline 379
 06E6 82D4              xjmp L65
 06E8           L101:
 06E8                   .dbline 382
 06E8           ;                       
 06E8           ;                       // If there is any data after the last arg, then the format is invalid and it should return an error
 06E8           ;                       if (cstrtok(0x00, " ") != 0x00) goto error;     
 06E8 5031              mov A,>L57
 06EA 08                push A
 06EB 5031              mov A,<L57
 06ED 08                push A
 06EE 5000              mov A,0
 06F0 08                push A
 06F1 08                push A
 06F2 7C0000            xcall _cstrtok
 06F5 38FC              add SP,-4
 06F7 62D000            mov REG[0xd0],>__r0
 06FA 3C0000            cmp [__r0],0
 06FD B006              jnz X29
 06FF 3C0000            cmp [__r1],0
 0702 A003              jz L104
 0704           X29:
 0704                   .dbline 382
 0704 82B6              xjmp L65
 0706           L104:
 0706                   .dbline 384
 0706           ;                       
 0706           ;                       if (samplingRate < 0 || samplingRate > 9)
 0706 5205              mov A,[X+5]
 0708 1100              sub A,0
 070A 5204              mov A,[X+4]
 070C 3180              xor A,-128
 070E 1980              sbb A,(0 ^ 0x80)
 0710 C014              jc L108
 0712           X30:
 0712 5009              mov A,9
 0714 1305              sub A,[X+5]
 0716 5204              mov A,[X+4]
 0718 3180              xor A,-128
 071A 62D000            mov REG[0xd0],>__r0
 071D 5300              mov [__rX],A
 071F 5080              mov A,(0 ^ 0x80)
 0721 1A00              sbb A,[__rX]
 0723 D003              jnc L106
 0725           X31:
 0725           L108:
 0725                   .dbline 385
 0725           ;                               goto error; // Invalid sampling rate was selected
 0725 8295              xjmp L65
 0727           L106:
 0727                   .dbline 387
 0727           ;                       
 0727           ;                       switch (samplingRate)
 0727 3D0400            cmp [X+4],0
 072A B006              jnz X32
 072C 3D0501            cmp [X+5],1
 072F A053              jz L111
 0731           X32:
 0731 3D0400            cmp [X+4],0
 0734 B006              jnz X33
 0736 3D0502            cmp [X+5],2
 0739 A051              jz L112
 073B           X33:
 073B 3D0400            cmp [X+4],0
 073E B006              jnz X34
 0740 3D0503            cmp [X+5],3
 0743 A04F              jz L113
 0745           X34:
 0745 3D0400            cmp [X+4],0
 0748 B006              jnz X35
 074A 3D0504            cmp [X+5],4
 074D A04D              jz L114
 074F           X35:
 074F 3D0400            cmp [X+4],0
 0752 B006              jnz X36
 0754 3D0505            cmp [X+5],5
 0757 A04B              jz L115
 0759           X36:
 0759 3D0400            cmp [X+4],0
 075C B006              jnz X37
 075E 3D0506            cmp [X+5],6
 0761 A049              jz L116
 0763           X37:
 0763 3D0400            cmp [X+4],0
 0766 B006              jnz X38
 0768 3D0507            cmp [X+5],7
 076B A047              jz L117
 076D           X38:
 076D 3D0400            cmp [X+4],0
 0770 B006              jnz X39
 0772 3D0508            cmp [X+5],8
 0775 A045              jz L118
 0777           X39:
 0777 3D0400            cmp [X+4],0
 077A B006              jnz X40
 077C 3D0509            cmp [X+5],9
 077F A043              jz L119
 0781           X40:
 0781 8047              xjmp L110
 0783           L111:
 0783                   .dbline 389
 0783           ;                       {
 0783           ;                               case 1: ksps = SAMPLING_RATE_1250; break;
 0783 560795            mov [X+7],-107
 0786 560600            mov [X+6],0
 0789                   .dbline 389
 0789 803F              xjmp L110
 078B           L112:
 078B                   .dbline 390
 078B           ;                               case 2: ksps = SAMPLING_RATE_1500; break;
 078B 56077C            mov [X+7],124
 078E 560600            mov [X+6],0
 0791                   .dbline 390
 0791 8037              xjmp L110
 0793           L113:
 0793                   .dbline 391
 0793           ;                               case 3: ksps = SAMPLING_RATE_1875; break;
 0793 560763            mov [X+7],99
 0796 560600            mov [X+6],0
 0799                   .dbline 391
 0799 802F              xjmp L110
 079B           L114:
 079B                   .dbline 392
 079B           ;                               case 4: ksps = SAMPLING_RATE_2500; break;
 079B 56074A            mov [X+7],74
 079E 560600            mov [X+6],0
 07A1                   .dbline 392
 07A1 8027              xjmp L110
 07A3           L115:
 07A3                   .dbline 393
 07A3           ;                               case 5: ksps = SAMPLING_RATE_3125; break;
 07A3 56073B            mov [X+7],59
 07A6 560600            mov [X+6],0
 07A9                   .dbline 393
 07A9 801F              xjmp L110
 07AB           L116:
 07AB                   .dbline 394
 07AB           ;                               case 6: ksps = SAMPLING_RATE_3750; break;
 07AB 560731            mov [X+7],49
 07AE 560600            mov [X+6],0
 07B1                   .dbline 394
 07B1 8017              xjmp L110
 07B3           L117:
 07B3                   .dbline 395
 07B3           ;                               case 7: ksps = SAMPLING_RATE_6250; break;
 07B3 56071D            mov [X+7],29
 07B6 560600            mov [X+6],0
 07B9                   .dbline 395
 07B9 800F              xjmp L110
 07BB           L118:
 07BB                   .dbline 396
 07BB           ;                               case 8: ksps = SAMPLING_RATE_7500; break;
 07BB 560718            mov [X+7],24
 07BE 560600            mov [X+6],0
 07C1                   .dbline 396
 07C1 8007              xjmp L110
 07C3           L119:
 07C3                   .dbline 397
 07C3           ;                               case 9: ksps = SAMPLING_RATE_9375; break;
 07C3 560713            mov [X+7],19
 07C6 560600            mov [X+6],0
 07C9                   .dbline 397
 07C9                   .dbline 398
 07C9           ;                               default: break;
 07C9           L110:
 07C9                   .dbline 401
 07C9           ;                       }
 07C9           ;                       
 07C9           ;                       DelSigClock_Stop(); // Stop the DelSigClock before writing
 07C9 10                push X
 07CA 7C0000            xcall _DelSigClock_Stop
 07CD 20                pop X
 07CE                   .dbline 402
 07CE           ;                       DelSigClock_WritePeriod(ksps);
 07CE 62D000            mov REG[0xd0],>__r0
 07D1 5207              mov A,[X+7]
 07D3 10                push X
 07D4 7C0000            xcall _DelSigClock_WritePeriod
 07D7 20                pop X
 07D8                   .dbline 403
 07D8           ;                       DelSigClock_WriteCompareValue(ksps>>1); // 50% duty cycle
 07D8 62D000            mov REG[0xd0],>__r0
 07DB 5207              mov A,[X+7]
 07DD 5300              mov [__r1],A
 07DF 5206              mov A,[X+6]
 07E1 5300              mov [__r0],A
 07E3 6800              asr [__r0]
 07E5 6E00              rrc [__r1]
 07E7 5100              mov A,[__r1]
 07E9 10                push X
 07EA 7C0000            xcall _DelSigClock_WriteCompareValue
 07ED                   .dbline 404
 07ED           ;                       DelSigClock_Start(); // Start it again
 07ED 7C0000            xcall _DelSigClock_Start
 07F0 20                pop X
 07F1                   .dbline 405
 07F1           ;               }
 07F1 81D5              xjmp L55
 07F3           L98:
 07F3                   .dbline 406
 07F3           ;               else if (!cstrcmp("trigger", cmd)) // If the command trigger was entered
 07F3 5202              mov A,[X+2]
 07F5 08                push A
 07F6 5203              mov A,[X+3]
 07F8 08                push A
 07F9 5011              mov A,>L122
 07FB 08                push A
 07FC 5011              mov A,<L122
 07FE 08                push A
 07FF 7C0000            xcall _cstrcmpLMM
 0802 38FC              add SP,-4
 0804 62D000            mov REG[0xd0],>__r0
 0807 3C0000            cmp [__r0],0
 080A B16F              jnz L120
 080C 3C0000            cmp [__r1],0
 080F B16A              jnz L120
 0811           X41:
 0811                   .dbline 408
 0811           ;               {
 0811           ;                       int address;
 0811                   .dbline 414
 0811           ; 
 0811           ;                       // csscanf if used to parse the string into values such as hexadecimal or integers
 0811           ;                       // It returns the number of parameters it parsed which should be one
 0811           ;                       // If the length of the params is not right or it does not parse the right amount, it returns an error
 0811           ;                       // %d gets an integer, this is the memory block
 0811           ;                       params = Lowercase(cstrtok(0x00, " "));
 0811 5031              mov A,>L57
 0813 08                push A
 0814 5031              mov A,<L57
 0816 08                push A
 0817 5000              mov A,0
 0819 08                push A
 081A 08                push A
 081B 7C0000            xcall _cstrtok
 081E 38FC              add SP,-4
 0820 62D000            mov REG[0xd0],>__r0
 0823 5100              mov A,[__r0]
 0825 08                push A
 0826 5100              mov A,[__r1]
 0828 08                push A
 0829 9879              xcall _Lowercase
 082B 62D000            mov REG[0xd0],>__r0
 082E 5100              mov A,[__r1]
 0830 5401              mov [X+1],A
 0832 5100              mov A,[__r0]
 0834 5400              mov [X+0],A
 0836                   .dbline 415
 0836           ;                       if (!cstrcmp("hex", params))
 0836 5200              mov A,[X+0]
 0838 08                push A
 0839 5201              mov A,[X+1]
 083B 08                push A
 083C 500D              mov A,>L125
 083E 08                push A
 083F 500D              mov A,<L125
 0841 08                push A
 0842 7C0000            xcall _cstrcmpLMM
 0845 38FA              add SP,-6
 0847 62D000            mov REG[0xd0],>__r0
 084A 3C0000            cmp [__r0],0
 084D B064              jnz L123
 084F 3C0000            cmp [__r1],0
 0852 B05F              jnz L123
 0854           X42:
 0854                   .dbline 418
 0854           ;                       {
 0854           ;                               // %x gets a hexadecimal value, this can read capital or lowercase letters, this is the address
 0854           ;                               params = cstrtok(0x00, " ");
 0854                   .dbline 418
 0854 5031              mov A,>L57
 0856 08                push A
 0857 5031              mov A,<L57
 0859 08                push A
 085A 5000              mov A,0
 085C 08                push A
 085D 08                push A
 085E 7C0000            xcall _cstrtok
 0861 62D000            mov REG[0xd0],>__r0
 0864 5100              mov A,[__r1]
 0866 5401              mov [X+1],A
 0868 5100              mov A,[__r0]
 086A 5400              mov [X+0],A
 086C                   .dbline 419
 086C           ;                               if (strlen(params) > 4 || csscanf(params, "%x", &address) != 1) goto error;
 086C 5200              mov A,[X+0]
 086E 08                push A
 086F 5201              mov A,[X+1]
 0871 08                push A
 0872 7C0000            xcall _strlenLMM
 0875 38FA              add SP,-6
 0877 62D000            mov REG[0xd0],>__r0
 087A 5004              mov A,4
 087C 1200              sub A,[__r1]
 087E 5000              mov A,0
 0880 1A00              sbb A,[__r0]
 0882 C02D              jc L129
 0884           X43:
 0884 62D000            mov REG[0xd0],>__r0
 0887 5A00              mov [__r1],X
 0889 060004            add [__r1],4
 088C 5007              mov A,7
 088E 08                push A
 088F 5100              mov A,[__r1]
 0891 08                push A
 0892 500A              mov A,>L128
 0894 08                push A
 0895 500A              mov A,<L128
 0897 08                push A
 0898 5200              mov A,[X+0]
 089A 08                push A
 089B 5201              mov A,[X+1]
 089D 08                push A
 089E 7C0000            xcall _csscanf
 08A1 38FA              add SP,-6
 08A3 62D000            mov REG[0xd0],>__r0
 08A6 3C0000            cmp [__r0],0
 08A9 B006              jnz X44
 08AB 3C0001            cmp [__r1],1
 08AE A07F              jz L124
 08B0           X44:
 08B0           L129:
 08B0                   .dbline 419
 08B0 810A              xjmp L65
 08B2           L123:
 08B2                   .dbline 421
 08B2           ;                       }
 08B2           ;                       else if (!cstrcmp("dec", params))
 08B2 5200              mov A,[X+0]
 08B4 08                push A
 08B5 5201              mov A,[X+1]
 08B7 08                push A
 08B8 5006              mov A,>L132
 08BA 08                push A
 08BB 5006              mov A,<L132
 08BD 08                push A
 08BE 7C0000            xcall _cstrcmpLMM
 08C1 38FC              add SP,-4
 08C3 62D000            mov REG[0xd0],>__r0
 08C6 3C0000            cmp [__r0],0
 08C9 B0F1              jnz L65
 08CB 3C0000            cmp [__r1],0
 08CE B0EC              jnz L65
 08D0           X45:
 08D0                   .dbline 423
 08D0           ;                       {
 08D0           ;                               params = cstrtok(0x00, " ");
 08D0                   .dbline 423
 08D0 5031              mov A,>L57
 08D2 08                push A
 08D3 5031              mov A,<L57
 08D5 08                push A
 08D6 5000              mov A,0
 08D8 08                push A
 08D9 08                push A
 08DA 7C0000            xcall _cstrtok
 08DD 62D000            mov REG[0xd0],>__r0
 08E0 5100              mov A,[__r1]
 08E2 5401              mov [X+1],A
 08E4 5100              mov A,[__r0]
 08E6 5400              mov [X+0],A
 08E8                   .dbline 425
 08E8           ;                               // %d gets an integer, this is the address
 08E8           ;                               if (strlen(params) > 4 || csscanf(params, "%d", &address) != 1) goto error;
 08E8 5200              mov A,[X+0]
 08EA 08                push A
 08EB 5201              mov A,[X+1]
 08ED 08                push A
 08EE 7C0000            xcall _strlenLMM
 08F1 38FA              add SP,-6
 08F3 62D000            mov REG[0xd0],>__r0
 08F6 5004              mov A,4
 08F8 1200              sub A,[__r1]
 08FA 5000              mov A,0
 08FC 1A00              sbb A,[__r0]
 08FE C02D              jc L135
 0900           X46:
 0900 62D000            mov REG[0xd0],>__r0
 0903 5A00              mov [__r1],X
 0905 060004            add [__r1],4
 0908 5007              mov A,7
 090A 08                push A
 090B 5100              mov A,[__r1]
 090D 08                push A
 090E 5025              mov A,>L68
 0910 08                push A
 0911 5025              mov A,<L68
 0913 08                push A
 0914 5200              mov A,[X+0]
 0916 08                push A
 0917 5201              mov A,[X+1]
 0919 08                push A
 091A 7C0000            xcall _csscanf
 091D 38FA              add SP,-6
 091F 62D000            mov REG[0xd0],>__r0
 0922 3C0000            cmp [__r0],0
 0925 B006              jnz X47
 0927 3C0001            cmp [__r1],1
 092A A003              jz L131
 092C           X47:
 092C           L135:
 092C                   .dbline 425
 092C 808E              xjmp L65
 092E           L131:
 092E           L124:
 092E                   .dbline 430
 092E           ;                       }
 092E           ;                       else 
 092E           ;                               goto error; // Invalid data type entered
 092E           ;                       
 092E           ;                       if (address < 0 || address > 8192)
 092E 5205              mov A,[X+5]
 0930 1100              sub A,0
 0932 5204              mov A,[X+4]
 0934 3180              xor A,-128
 0936 1980              sbb A,(0 ^ 0x80)
 0938 C014              jc L138
 093A           X48:
 093A 5000              mov A,0
 093C 1305              sub A,[X+5]
 093E 5204              mov A,[X+4]
 0940 3180              xor A,-128
 0942 62D000            mov REG[0xd0],>__r0
 0945 5300              mov [__rX],A
 0947 50A0              mov A,(32 ^ 0x80)
 0949 1A00              sbb A,[__rX]
 094B D003              jnc L136
 094D           X49:
 094D           L138:
 094D                   .dbline 431
 094D           ;                               goto error; // Invalid address range specified
 094D 806D              xjmp L65
 094F           L136:
 094F                   .dbline 434
 094F           ; 
 094F           ;                       // If there is any data after the last arg, then the format is invalid and it should return an error
 094F           ;                       if (cstrtok(0x00, " ") != 0x00) goto error;
 094F 5031              mov A,>L57
 0951 08                push A
 0952 5031              mov A,<L57
 0954 08                push A
 0955 5000              mov A,0
 0957 08                push A
 0958 08                push A
 0959 7C0000            xcall _cstrtok
 095C 38FC              add SP,-4
 095E 62D000            mov REG[0xd0],>__r0
 0961 3C0000            cmp [__r0],0
 0964 B006              jnz X50
 0966 3C0000            cmp [__r1],0
 0969 A003              jz L139
 096B           X50:
 096B                   .dbline 434
 096B 804F              xjmp L65
 096D           L139:
 096D                   .dbline 437
 096D           ;               
 096D           ;                       // triggerAddress is the specified address
 096D           ;                       triggerAddress = address;
 096D 62D000            mov REG[0xd0],>_triggerAddress
 0970 5205              mov A,[X+5]
 0972 5301              mov [_triggerAddress+1],A
 0974 5204              mov A,[X+4]
 0976 5300              mov [_triggerAddress],A
 0978                   .dbline 439
 0978           ;                       
 0978           ;               }
 0978 804E              xjmp L55
 097A           L120:
 097A                   .dbline 440
 097A           ;               else if (!cstrcmp("start", cmd)) // If the command start was entered
 097A 5202              mov A,[X+2]
 097C 08                push A
 097D 5203              mov A,[X+3]
 097F 08                push A
 0980 5000              mov A,>L143
 0982 08                push A
 0983 5000              mov A,<L143
 0985 08                push A
 0986 7C0000            xcall _cstrcmpLMM
 0989 38FC              add SP,-4
 098B 62D000            mov REG[0xd0],>__r0
 098E 3C0000            cmp [__r0],0
 0991 B029              jnz L65
 0993 3C0000            cmp [__r1],0
 0996 B024              jnz L65
 0998           X51:
 0998                   .dbline 443
 0998           ;               {
 0998           ;                       // If there is any data after the number of bytes, then the format is invalid and it should return an error
 0998           ;                       if (cstrtok(0x00, " ") != 0x00) goto error;
 0998                   .dbline 443
 0998 5031              mov A,>L57
 099A 08                push A
 099B 5031              mov A,<L57
 099D 08                push A
 099E 5000              mov A,0
 09A0 08                push A
 09A1 08                push A
 09A2 7C0000            xcall _cstrtok
 09A5 38FC              add SP,-4
 09A7 62D000            mov REG[0xd0],>__r0
 09AA 3C0000            cmp [__r0],0
 09AD B006              jnz X52
 09AF 3C0000            cmp [__r1],0
 09B2 A003              jz L144
 09B4           X52:
 09B4                   .dbline 443
 09B4 8006              xjmp L65
 09B6           L144:
 09B6                   .dbline 446
 09B6           ;                       
 09B6           ;                       // Start playing the data
 09B6           ;                       PlaySamples();
 09B6 7C0113            xcall _PlaySamples
 09B9                   .dbline 447
 09B9           ;               }
 09B9                   .dbline 449
 09B9           ;               else 
 09B9           ;                       goto error;
 09B9                   .dbline 451
 09B9           ;               
 09B9           ;               continue; // This is so that the error is skipped when everything goes right
 09B9 800D              xjmp L55
 09BB           L65:
 09BB                   .dbline 453
 09BB           ;               error: // This outputs an invalid format message and continues on to read another line
 09BB           ;                       UART_CPutString("########################## Lab 11 Data Acquisition System ########################\r\n\
 09BB 10                push X
 09BC 5033              mov A,>L53
 09BE 08                push A
 09BF 5033              mov A,<L53
 09C1 5C                mov X,A
 09C2 18                pop A
 09C3 7C0000            xcall _UART_CPutString
 09C6 20                pop X
 09C7                   .dbline 486
 09C7           ; # input X A \r\n\
 09C7           ; #\r\n\
 09C7           ; #     Samples input channel to memory block\r\n\
 09C7           ; #             X - Either A/B to signify channel being altered\r\n\
 09C7           ; #             A - Memory block(0-3) being routed\r\n\
 09C7           ; #\r\n\
 09C7           ; # output X A\r\n\
 09C7           ; #     Routes output channel to read from memory block \r\n\
 09C7           ; #             X - Either A/B to signify channel being altered\r\n\
 09C7           ; #             A - Memory block(0-3 or -1 for none) being routed\r\n\
 09C7           ; #\r\n\
 09C7           ; # rate X\r\n\
 09C7           ; #     Selects a rate to sample the channels when reading and writing\r\n\
 09C7           ; #             X - One of the values below\r\n\
 09C7           ; #                     1. 1.25  ksps \r\n\
 09C7           ; #                     2. 1.5   ksps\r\n\
 09C7           ; #                     3. 1.87  ksps\r\n\
 09C7           ; #                     4. 2.5   ksps\r\n\
 09C7           ; #                     5. 3.125 ksps\r\n\
 09C7           ; #                     6. 3.75  ksps\r\n\
 09C7           ; #                     7. 6.25  ksps\r\n\
 09C7           ; #                     8. 7.5   ksps\r\n\
 09C7           ; #                     9. 9.37  ksps\r\n\
 09C7           ; #\r\n\
 09C7           ; # trigger XXX H\r\n\
 09C7           ; #     Sets the relative address to trigger\r\n\
 09C7           ; #             XXX - Either hex/dec for the address\r\n\
 09C7           ; #             H - values in hexadecimal or decimal.  Range is 0-8192 for dec or 0-2000 for hex\r\n\
 09C7           ; #\r\n\
 09C7           ; # start\r\n\
 09C7           ; #     Starts the output channels. They will continue to play until looped over\r\n\
 09C7           ; #####################################################################\r\n");
 09C7           ;       }
 09C7           L55:
 09C7                   .dbline 306
 09C7 89BE              xjmp L54
 09C9           X9:
 09C9                   .dbline -2
 09C9           L52:
 09C9 38F7              add SP,-9
 09CB 20                pop X
 09CC                   .dbline 0 ; func end
 09CC 8FFF              jmp .
 09CE                   .dbsym l address 4 I
 09CE                   .dbsym l ksps 6 I
 09CE                   .dbsym l samplingRate 4 I
 09CE                   .dbsym l memBlock 5 I
 09CE                   .dbsym l channel 4 c
 09CE                   .dbsym l memBlock 5 I
 09CE                   .dbsym l channel 4 c
 09CE                   .dbsym l cmd 2 pc
 09CE                   .dbsym l params 0 pc
 09CE                   .dbend
 09CE                   .dbfunc e DACUpdate_ISR _DACUpdate_ISR fV
 09CE           _DACUpdate_ISR::
 09CE                   .dbline -1
 09CE 71C0              or F,-64
 09D0 08                push A
 09D1 5DD0              mov A,REG[0xd0]
 09D3 08                push A
 09D4                   .dbline 502
 09D4           ; 
 09D4           ; }
 09D4           ; 
 09D4           ; /*****************************************************************************/
 09D4           ; /********************* Interrupt Service Routines Below **********************/
 09D4           ; /*****************************************************************************/
 09D4           ; #pragma interrupt_handler DACUpdate_ISR
 09D4           ; 
 09D4           ; // DACUpdate_ISR is called at the terminal count of the DACUpdate user module.
 09D4           ; // Since it's clock source is the same as DelSig, setting its period to
 09D4           ; // match the DelSig PWM (4*DecimationRate) will cause it to interrupt at the
 09D4           ; // same rate as the DelSig's sampling rate. If the samples are only sent to
 09D4           ; // the DACs when the variable DACUpdateDone is one, the output sampling rate
 09D4           ; // can be controlled.
 09D4           ; void DACUpdate_ISR(void)
 09D4           ; {
 09D4                   .dbline 507
 09D4           ;       // Updating the DACs inside the ISR takes more clock cycles
 09D4           ;       // than simply setting a flag and exiting. This is because
 09D4           ;       // the C-compiler does a full preserve and restore of the
 09D4           ;       // CPU context which takes 190+185 CPU cycles.
 09D4           ;       DACUpdateDone = 1;
 09D4 62D000            mov REG[0xd0],>_DACUpdateDone
 09D7 550001            mov [_DACUpdateDone],1
 09DA                   .dbline -2
 09DA           L146:
 09DA 18                pop A
 09DB 60D0              mov REG[208],A
 09DD 18                pop A
 09DE                   .dbline 0 ; func end
 09DE 7E                reti
 09DF                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\addis\Desktop\ECE381\DATAAC~1\DATAAC~1\main.c
 0000           _buf::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 00000000000000000000      .word 0,0,0,0,0
 0046 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 0050                   .dbsym e buf _buf A[80:80]c
                        .area lit(rom, con, rel, lit)
 0000           L143:
 0000 737461727400      .byte 's,'t,'a,'r,'t,0
 0006           L132:
 0006 64656300          .byte 'd,'e,'c,0
 000A           L128:
 000A 257800            .byte 37,'x,0
 000D           L125:
 000D 68657800          .byte 'h,'e,'x,0
 0011           L122:
 0011 7472696767657200  .byte 't,'r,'i,'g,'g,'e,'r,0
 0019           L100:
 0019 7261746500        .byte 'r,'a,'t,'e,0
 001E           L82:
 001E 6F757470757400    .byte 'o,'u,'t,'p,'u,'t,0
 0025           L68:
 0025 256400            .byte 37,'d,0
 0028           L63:
 0028 256300            .byte 37,'c,0
 002B           L60:
 002B 696E70757400      .byte 'i,'n,'p,'u,'t,0
 0031           L57:
 0031 2000              .byte 32,0
 0033           L53:
 0033 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0043 23232323232323232323204C61622031  .byte 35,35,35,35,35,35,35,35,35,35,32,'L,'a,'b,32,49
 0053 31204461746120416371756973697469  .byte 49,32,'D,'a,'t,'a,32,'A,'c,'q,'u,'i,'s,'i,'t,'i
 0063 6F6E2053797374656D20232323232323  .byte 'o,'n,32,'S,'y,'s,'t,'e,'m,32,35,35,35,35,35,35
 0073 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0083 23230D0A2320696E7075742058204120  .byte 35,35,13,10,35,32,'i,'n,'p,'u,'t,32,'X,32,'A,32
 0093 0D0A230D0A230953616D706C65732069  .byte 13,10,35,13,10,35,9,'S,'a,'m,'p,'l,'e,'s,32,'i
 00A3 6E707574206368616E6E656C20746F20  .byte 'n,'p,'u,'t,32,'c,'h,'a,'n,'n,'e,'l,32,'t,'o,32
 00B3 6D656D6F727920626C6F636B0D0A2309  .byte 'm,'e,'m,'o,'r,'y,32,'b,'l,'o,'c,'k,13,10,35,9
 00C3 0958202D2045697468657220412F4220  .byte 9,'X,32,45,32,'E,'i,'t,'h,'e,'r,32,'A,47,'B,32
 00D3 746F207369676E696679206368616E6E  .byte 't,'o,32,'s,'i,'g,'n,'i,'f,'y,32,'c,'h,'a,'n,'n
 00E3 656C206265696E6720616C7465726564  .byte 'e,'l,32,'b,'e,'i,'n,'g,32,'a,'l,'t,'e,'r,'e,'d
 00F3 0D0A23090941202D204D656D6F727920  .byte 13,10,35,9,9,'A,32,45,32,'M,'e,'m,'o,'r,'y,32
 0103 626C6F636B28302D3329206265696E67  .byte 'b,'l,'o,'c,'k,40,48,45,51,41,32,'b,'e,'i,'n,'g
 0113 20726F757465640D0A230D0A23206F75  .byte 32,'r,'o,'u,'t,'e,'d,13,10,35,13,10,35,32,'o,'u
 0123 74707574205820410D0A2309526F7574  .byte 't,'p,'u,'t,32,'X,32,'A,13,10,35,9,'R,'o,'u,'t
 0133 6573206F7574707574206368616E6E65  .byte 'e,'s,32,'o,'u,'t,'p,'u,'t,32,'c,'h,'a,'n,'n,'e
 0143 6C20746F20726561642066726F6D206D  .byte 'l,32,'t,'o,32,'r,'e,'a,'d,32,'f,'r,'o,'m,32,'m
 0153 656D6F727920626C6F636B200D0A2309  .byte 'e,'m,'o,'r,'y,32,'b,'l,'o,'c,'k,32,13,10,35,9
 0163 0958202D2045697468657220412F4220  .byte 9,'X,32,45,32,'E,'i,'t,'h,'e,'r,32,'A,47,'B,32
 0173 746F207369676E696679206368616E6E  .byte 't,'o,32,'s,'i,'g,'n,'i,'f,'y,32,'c,'h,'a,'n,'n
 0183 656C206265696E6720616C7465726564  .byte 'e,'l,32,'b,'e,'i,'n,'g,32,'a,'l,'t,'e,'r,'e,'d
 0193 0D0A23090941202D204D656D6F727920  .byte 13,10,35,9,9,'A,32,45,32,'M,'e,'m,'o,'r,'y,32
 01A3 626C6F636B28302D33206F72202D3120  .byte 'b,'l,'o,'c,'k,40,48,45,51,32,'o,'r,32,45,49,32
 01B3 666F72206E6F6E6529206265696E6720  .byte 'f,'o,'r,32,'n,'o,'n,'e,41,32,'b,'e,'i,'n,'g,32
 01C3 726F757465640D0A230D0A2320726174  .byte 'r,'o,'u,'t,'e,'d,13,10,35,13,10,35,32,'r,'a,'t
 01D3 6520580D0A230953656C656374732061  .byte 'e,32,'X,13,10,35,9,'S,'e,'l,'e,'c,'t,'s,32,'a
 01E3 207261746520746F2073616D706C6520  .byte 32,'r,'a,'t,'e,32,'t,'o,32,'s,'a,'m,'p,'l,'e,32
 01F3 746865206368616E6E656C7320776865  .byte 't,'h,'e,32,'c,'h,'a,'n,'n,'e,'l,'s,32,'w,'h,'e
 0203 6E2072656164696E6720616E64207772  .byte 'n,32,'r,'e,'a,'d,'i,'n,'g,32,'a,'n,'d,32,'w,'r
 0213 6974696E670D0A23090958202D204F6E  .byte 'i,'t,'i,'n,'g,13,10,35,9,9,'X,32,45,32,'O,'n
 0223 65206F66207468652076616C75657320  .byte 'e,32,'o,'f,32,'t,'h,'e,32,'v,'a,'l,'u,'e,'s,32
 0233 62656C6F770D0A23090909312E20312E  .byte 'b,'e,'l,'o,'w,13,10,35,9,9,9,49,46,32,49,46
 0243 323520206B737073200D0A2309090932  .byte 50,53,32,32,'k,'s,'p,'s,32,13,10,35,9,9,9,50
 0253 2E20312E352020206B7370730D0A2309  .byte 46,32,49,46,53,32,32,32,'k,'s,'p,'s,13,10,35,9
 0263 0909332E20312E383720206B7370730D  .byte 9,9,51,46,32,49,46,56,55,32,32,'k,'s,'p,'s,13
 0273 0A23090909342E20322E352020206B73  .byte 10,35,9,9,9,52,46,32,50,46,53,32,32,32,'k,'s
 0283 70730D0A23090909352E20332E313235  .byte 'p,'s,13,10,35,9,9,9,53,46,32,51,46,49,50,53
 0293 206B7370730D0A23090909362E20332E  .byte 32,'k,'s,'p,'s,13,10,35,9,9,9,54,46,32,51,46
 02A3 373520206B7370730D0A23090909372E  .byte 55,53,32,32,'k,'s,'p,'s,13,10,35,9,9,9,55,46
 02B3 20362E323520206B7370730D0A230909  .byte 32,54,46,50,53,32,32,'k,'s,'p,'s,13,10,35,9,9
 02C3 09382E20372E352020206B7370730D0A  .byte 9,56,46,32,55,46,53,32,32,32,'k,'s,'p,'s,13,10
 02D3 23090909392E20392E333720206B7370  .byte 35,9,9,9,57,46,32,57,46,51,55,32,32,'k,'s,'p
 02E3 730D0A230D0A23207472696767657220  .byte 's,13,10,35,13,10,35,32,'t,'r,'i,'g,'g,'e,'r,32
 02F3 58585820480D0A230953657473207468  .byte 'X,'X,'X,32,'H,13,10,35,9,'S,'e,'t,'s,32,'t,'h
 0303 652072656C6174697665206164647265  .byte 'e,32,'r,'e,'l,'a,'t,'i,'v,'e,32,'a,'d,'d,'r,'e
 0313 737320746F20747269676765720D0A23  .byte 's,'s,32,'t,'o,32,'t,'r,'i,'g,'g,'e,'r,13,10,35
 0323 0909585858202D204569746865722068  .byte 9,9,'X,'X,'X,32,45,32,'E,'i,'t,'h,'e,'r,32,'h
 0333 65782F64656320666F72207468652061  .byte 'e,'x,47,'d,'e,'c,32,'f,'o,'r,32,'t,'h,'e,32,'a
 0343 6464726573730D0A23090948202D2076  .byte 'd,'d,'r,'e,'s,'s,13,10,35,9,9,'H,32,45,32,'v
 0353 616C75657320696E2068657861646563  .byte 'a,'l,'u,'e,'s,32,'i,'n,32,'h,'e,'x,'a,'d,'e,'c
 0363 696D616C206F7220646563696D616C2E  .byte 'i,'m,'a,'l,32,'o,'r,32,'d,'e,'c,'i,'m,'a,'l,46
 0373 202052616E676520697320302D383139  .byte 32,32,'R,'a,'n,'g,'e,32,'i,'s,32,48,45,56,49,57
 0383 3220666F7220646563206F7220302D32  .byte 50,32,'f,'o,'r,32,'d,'e,'c,32,'o,'r,32,48,45,50
 0393 30303020666F72206865780D0A230D0A  .byte 48,48,48,32,'f,'o,'r,32,'h,'e,'x,13,10,35,13,10
 03A3 232073746172740D0A23095374617274  .byte 35,32,'s,'t,'a,'r,'t,13,10,35,9,'S,'t,'a,'r,'t
 03B3 7320746865206F757470757420636861  .byte 's,32,'t,'h,'e,32,'o,'u,'t,'p,'u,'t,32,'c,'h,'a
 03C3 6E6E656C732E20546865792077696C6C  .byte 'n,'n,'e,'l,'s,46,32,'T,'h,'e,'y,32,'w,'i,'l,'l
 03D3 20636F6E74696E756520746F20706C61  .byte 32,'c,'o,'n,'t,'i,'n,'u,'e,32,'t,'o,32,'p,'l,'a
 03E3 7920756E74696C206C6F6F706564206F  .byte 'y,32,'u,'n,'t,'i,'l,32,'l,'o,'o,'p,'e,'d,32,'o
 03F3 7665720D0A2323232323232323232323  .byte 'v,'e,'r,13,10,35,35,35,35,35,35,35,35,35,35,35
 0403 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0413 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0423 23232323232323232323232323232323  .byte 35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35
 0433 232323232323232323230D0A00        .byte 35,35,35,35,35,35,35,35,35,35,13,10,0
 0440           L23:
 0440 507265737320616E79206B657920746F  .byte 'P,'r,'e,'s,'s,32,'a,'n,'y,32,'k,'e,'y,32,'t,'o
 0450 2061626F72740D0A00        .byte 32,'a,'b,'o,'r,'t,13,10,0
